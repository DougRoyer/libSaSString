//
// BEGIN_SOFTWARE_AND_SERVICES_COPYRIGHT
//
// Copyright (C) 2010-2015,2019-2020 Douglas Mark Royer, All Rights Reserved.
//
// NOTICE:
//
// THIS SOURCE CODE BELONGS TO DOUGLAS MARK ROYER
// THIS CODE IS PROPERTY OF THE COPYRIGHT HOLDER AND IS NOT TO
// BE DIVULGED OR USED BY PARTIES WHO HAVE NOT RECEIVED WRITTEN
// AUTHORIZATION FROM THE OWNER.
//
// THIS SOFTWARE AND MANUAL ARE BOTH PROTECTED BY UNITED STATES
// COPYRIGHT LAW (TITLE 17 UNITED STATES CODE). UNAUTHORIZED REPRODUCTION
// AND/OR SALE MAY RESULT IN IMPRISONMENT OF UP TO ONE YEAR AND FINES
// OF UP TO $100,000 (17 USC 506). COPYRIGHT INFRINGERS MAY ALSO
// BE SUBJECT TO CIVIL LIABILITY.
//
// THIS NOTICE AND THE ABOVE COPYRIGHT NOTICE MUST REMAIN IN ALL
// COPIES AND ANY DERIVED WORK.
//
// all OF THIS CODE IS ORIGINAL WORK BY THE COPYRIGHT HOLDER.
//
// THIS  DOCUMENT  AND  THE  INFORMATION  CONTAINED  HEREIN  IS
// PROVIDED  ON  AN "AS IS" BASIS AND DOUGLAS MARK ROYER
// DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,  INCLUDING  BUT
// NOT  LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
// HEREIN  WILL  NOT  INFRINGE  ANY  RIGHTS  OR   ANY   IMPLIED
// WARRANTIES  OF  MERCHANTABILITY  OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// END_SOFTWARE_AND_SERVICES_COPYRIGHT
//

/**
 * @file String.hpp "<SaS/String/String.hpp>"
 * @ingroup STRING
 * String manipulation routines for C++
 */
#ifndef SOFTWARE_AND_SERVICES_LIBRARY_STRING_STRING_HPP_
#define SOFTWARE_AND_SERVICES_LIBRARY_STRING_STRING_HPP_

#include <SaS/Common/osver.h>
#include <SaS/Common/instance.hpp>
#include <SaS/String/String.hpp>
#include <SaS/Common/XdrSerialize.hpp>
#include <SaS/Common/File.hpp>
#include <string>

#ifdef WIN32
#pragma warning (disable : 4251)
#endif

namespace SoftwareAndServices {
	namespace Library {
		namespace Common {
		}
	}
}

#include <SaS/Common/winWrappers.hpp>
#include <SaS/Common/Tokens.h>
#include <SaS/Common/DateTime.hpp>

#include <wchar.h>

#if !defined(WIN32) && !defined(WIN32_POSIX)
#include <strings.h>
#else
#include <string.h>
#endif

#include <string>
#include <ctype.h>
#include <memory.h>
#include <locale.h>
#include <vector>
#include <iterator>
#include <type_traits>
#include <stdarg.h>

using namespace SoftwareAndServices::Library::Common;

namespace SoftwareAndServices {
	namespace Library {
		namespace Common {

			class DateTime;		// Forward Ref.

			/**
			 * An enumeration of character widths: 8, 16, or 32 bits.
			 */
			enum CharacterUnitWidth_e {

				/**
				* Unknown, not set.
				*/
				IsUnknownBit_t	= 0,

				/**
				* The String or StringSeq is in 8 bit values.
				*/
				Is8Bit_t	= 1,

				/**
				* The String or StringSeq is in 16 bit values.
				*/
				Is16Bit_t	= 2,

				/**
				* The String or StringSeq is in 32 bit values.
				*/
				Is32Bit_t	= 3,

				/**
				* The String or StringSeq is in wchar_t values.
				*/
				IsWBit_t	= 4
			};

			/**
			 * The 8-bit Locale default.
			 */
			extern locale_t		Default8BitLocale;

			/**
			 * The 16-bit Locale default.
			 */
			extern locale_t		Default16BitLocale;

			/**
			 * The 32-bit Locale default.
			 */
			extern locale_t		Default32BitLocale;

			/**
			 * The W-bit (wchar_t) Locale default.
			 */
			extern locale_t		DefaultWBitLocale;

			/**
			 * The 8-bit Locale.
			 */
			extern locale_t		Current8BitLocale;

			/**
			 * The 16-bit Locale.
			 */
			extern locale_t		Current16BitLocale;

			/**
			 * The 32-bit Locale.
			 */
			extern locale_t		Current32BitLocale;

			/**
			 * The W-bit (wchar_t) Locale.
			 */
			extern locale_t		CurrentWBitLocale;

			/**
			 * The 8-bit Charset default.
			 */
			extern const char	* const	Default8BitCharset;

			/**
			 * The 16-bit Charset default.
			 */
			extern const char	* const	Default16BitCharset;

			/**
			 * The 32-bit Charset default.
			 */
			extern const char	* const	Default32BitCharset;

			/**
			 * The wchar_t Charset default.
			 */
			extern const char	* const	DefaultWBitCharset;

			/**
			 * The 8-bit Charset.
			 * A StringCache pointer.
			 */
			extern const char	 *	Current8BitCharset;

			/**
			 * The 16-bit Charset.
			 * A StringCache pointer.
			 */
			extern const char	 *	Current16BitCharset;

			/**
			 * The 32-bit Charset.
			 * A StringCache pointer.
			 */
			extern const char	 *	Current32BitCharset;

			/**
			 * The wchar_t Charset.
			 * A StringCache pointer.
			 */
			extern const char	 *	CurrentWBitCharset;

			/**
			 * The minimum width of the Default8BitCharset
			 * in octets.
			 */
			extern CharacterUnitWidth_e	const Default8BitWidth;

			/**
			 * The minimum width of the Default16BitCharset
			 * in octets.
			 */
			extern CharacterUnitWidth_e	const Default16BitWidth;

			/**
			 * The minimum width of the Default32BitCharset
			 * in octets.
			 */
			extern CharacterUnitWidth_e	const Default32BitWidth;

			/**
			 * The minimum width of the DefaultWBitCharset
			 * in octets.
			 */
			extern CharacterUnitWidth_e	const DefaultWBitWidth;

			/**
			 * The minimum width of the Current8BitCharset
			 * in octets.
			 */
			extern CharacterUnitWidth_e	const Current8BitWidth;

			/**
			 * The minimum width of the Current16BitCharset
			 * in octets.
			 */
			extern CharacterUnitWidth_e	const Current16BitWidth;

			/**
			 * The minimum width of the Current32BitCharset
			 * in octets.
			 */
			extern CharacterUnitWidth_e	const Current32BitWidth;

			/**
			 * The minimum width of the CurrentWBitCharset
			 * in octets.
			 */
			extern CharacterUnitWidth_e	const CurrentWBitWidth;

			/**
			 * Used all over the place, make a constant.
			 * Is set to "UTF-8".
			 */
			extern const char * const	Utf8_s;

			/**
			 * Used all over the place, make a constant.
			 * Is set to "UTF-16".
			 */
			extern const char * const	Utf16_s;

			/**
			 * Used all over the place, make a constant.
			 * Is set to "UTF-16LE".
			 */
			extern const char * const	Utf16LE_s;

			/**
			 * Used all over the place, make a constant.
			 * Is set to "UTF-16BE".
			 */
			extern const char * const	Utf16BE_s;

			/**
			 * Used all over the place, make a constant.
			 * Is set to "UTF-32".
			 */
			extern const char * const	Utf32_s;

			/**
			 * Used all over the place, make a constant.
			 * Is set to "UTF-32LE".
			 */
			extern const char * const	Utf32LE_s;

			/**
			 * Used all over the place, make a constant.
			 * Is set to "UTF-32BE".
			 */
			extern const char * const	Utf32BE_s;

			// Forward ref.
			//
			class ROString;

			/**
			 * @class String String.hpp "<SaS/String/String.hpp>"
			 * This is a class that allows:
			 *  - Conversion between multibyte and wide characters.
			 *  - Mixing (char), (char16_t), (char32_t), and (wchar_t)
			 * strings.
			 */
			class String
				: virtual public instance<String>,
				  public XdrSerialize<String> {

				public:

					/**
					 * String: Default Constructor
					 * Create an empty String object.
					 *
					 * The charset will be set to CurrentCharset.
					 * The character width will be set to CurrentCharsetWidth.
					 * Call Charset() on this object, before appending any text
					 * to set to another charset and width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String();

					/**
					 * String: Constructor
					 * Create an empty String object.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the default charset for CharsetWidth will be used.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to Current8BitCharset and
					 * CharsetWidth will be set to Is8Bit_t.
					 * -If Charset is not nullptr and CharsetWidth
					* is IsUnknownBit_t, then Charset will be set to Is8Bit_t.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const char * const Charset,
					       CharacterUnitWidth_e CharsetWidth);

					/**
					 * String: Constructor
					 * Create an empty String object.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param TheLocale An opened locale from setlocale.
					 */
					String(locale_t TheLocale);

					/**
					 * String: Copy Constructor
					 * Create a String object from another String object.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to ExistingStr.InputCharset() and
					 * CharsetWidth will be set to ExistingStr.InputWidth().
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the default charset for CharsetWidth will be used.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth will be set to Is8Bt_t.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const String & ExistingStr,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Copy Constructor
					 * Create a String object from another ROString object.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to ExistingStr.InputCharset() and
					 * CharsetWidth will be set to ExistingStr.InputWidth().
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the default charset for CharsetWidth will be used.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth will be set to Is8Bt_t.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const ROString & ExistingStr,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Constructor
					 * Create a String object from and existing (char*) string.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to Current8BitCharset and CharsetWidth
					 * will be set to Is8Bit_t.
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the charset will be set to the current charset for CharsetWidth.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth defaults to Current8BitCharset.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const char * const ExistingStr,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Constructor
					 * Create a String object from and existing (char16_t*) string.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to Current16BitCharset and CharsetWidth
					 * will be set to Is16Bit_t.
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the charset will be set to the current charset for CharsetWidth.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth defaults to Current16BitCharset.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const char16_t * const ExistingStr,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Constructor
					 * Create a String object from and existing (char32_t*) string.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to Current32BitCharset and CharsetWidth
					 * will be set to Is32Bit_t.
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the charset will be set to the current charset for CharsetWidth.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth defaults to Current32BitCharset.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const char32_t * const ExistingStr,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Constructor
					 * Create a String object from and existing (wchar_t*) string.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to CurrentWBitCharset and CharsetWidth
					 * will be set to IsWBit_t.
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the charset will be set to the current charset for CharsetWidth.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth defaults to CurrentWBitCharset.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const wchar_t * const ExistingStr,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Constructor
					 * Create a String object from and existing (std::string) string.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to Current8BitCharset and CharsetWidth
					 * will be set to Is8Bit_t.
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the charset will be set to the current charset for CharsetWidth.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth defaults to Current8BitCharset.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const std::string & ExistingStr,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Constructor
					 * Create a String object from and existing (std::u16string) string.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to Current16BitCharset and CharsetWidth
					 * will be set to Is16Bit_t.
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the charset will be set to the current charset for CharsetWidth.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth defaults to Current16BitCharset.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const std::u16string & ExistingStr,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Constructor
					 * Create a String object from and existing (std::u32string) string.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to Current32BitCharset and CharsetWidth
					 * will be set to Is32Bit_t.
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the charset will be set to the current charset for CharsetWidth.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth defaults to Current32BitCharset.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const std::u32string & ExistingString,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Constructor
					 * Create a String object from and existing (std::wstring) string.
					 *
					 * Sets the default input and output, charset and
					 * character width.
					 *
					 * You can still append any other charset and width to
					 * this object.
					 *
					 * You can still Get8(), Get16(). Get32(), or GetW() from
					 * this object, no matter the default charset.
					 *
					 * @param Charset the default charset for this object.
					 * -If Charset is nullptr and CharsetWidth is IsUnknownBit_t,
					 * Then Charset will be set to CurrentWBitCharset and CharsetWidth
					 * will be set to IsWBit_t.
					 * -If Charset is nullptr and CharsetWidth does not equal IsUnknownBit_t,
					 * then the charset will be set to the current charset for CharsetWidth.
					 * -If Charset is not nullptr and CharsetWidth is IsUnknownBit_t,
					 * then CharsetWidth defaults to CurrentWBitCharset.
					 *
					 * @param CharsetWidth the default charset width for this object.
					 *
					 * @see Charset()
					 * @see OutputCharset()
					 * @see InputCharset()
					 */
					String(const std::wstring & ExistingString,
					       const char * const Charset = nullptr,
					       CharacterUnitWidth_e CharsetWidth = IsUnknownBit_t);

					/**
					 * String: Destructor
					 */
					virtual ~String();

					/**
					 * Set both InputCharste() and OutputCharset() for this object.
					 *
					 * @param CharsetName The name of the charset.
					 *
					 * @param CharsetWidth The width of character unit in octets.
					 *
					 * @return true when Charset and CharsetWidth are valid.
					 *
					 * @note
					 * If never called on this object, or set at constructor time,
					 * it will have been set to Current8BitCharset, and Current8Width.
					 */
					bool	Charset(const char * CharsetName,
					                CharacterUnitWidth_e CharsetWidth);

					/**
					 * Set the input charset for this String.
					 * Once set, the default output charset will be CharsetName.
					 *
					 * @param CharsetName The character set name to make the default
					 * input charset for this object.
					 *
					 * @param CharsetWidth The width of character unit in octets.
					 * in this charset.
					 */
					void	InputCharset(const char * const CharsetName,
					                     CharacterUnitWidth_e CharsetWidth);

					/**
					 * Set the output charset for this String.
					 * Once set, the default output charset will be CharsetName.
					 *
					 * @param CharsetName The character set name to make the default
					 * output charset for this object.
					 *
					 * @param CharsetWidth The width of character unit in octets.
					 * in this charset.
					 */
					void	OutputCharset(const char * const CharsetName,
					                      CharacterUnitWidth_e CharsetWidth);

					/**
					 * Get the current input charset name.
					 *
					 * @return The default input charset name.
					 * A StringCache pointer.
					 */
					const char	*	InputCharset() const;

					/**
					 * Get the current input character width.
					 *
					 * @return The default input character width.
					 */
					CharacterUnitWidth_e	InputWidth() const;

					/**
					 * Get the current input charset name.
					 *
					 * @return The current input charset name.
					 * A StringCache pointer.
					 */
					const char	*	OutputCharset() const;

					/**
					 * Get the current input character width.
					 *
					 * @return The current input character width.
					 */
					CharacterUnitWidth_e	OutputWidth() const;

					/**
					 * Determine if this is a READ-ONLY string.
					 * All appends or modifications on IsReadOnly() String objects
					 * fail.
					 *
					 * Inside this String implementation, READ-ONLY strings
					 * are handled differently. They are handled as ROString objects
					 * that do NOT terminate the string with a NIL (0).
					 *
					 * When IsReadOnly() is true, the object is cast to a ROString
					 * and processed. IsReadOnly() String object do not have a
					 * Get8(), Get16(), Get32(), or GetW() methods, as those return
					 * NIL-terminated C-string values.
					 *
					 * For IsReadOnly() objects, use Get8(size_t), Get16(size_t),
					 * Get32(size_t), GetW(size_t), or the String:iterator or
					 * String::const_iterator set
					 * of methods to get to the underlying data.
					 *
					 * @return true when this string is a Read Only String,
					 * or a ROString.
					 */
					bool		IsReadOnly() const;

					enum IteratorDirection {
						/**
						* ItForward_t The iterator move forward. Adding to the
						* string iterator moves toward the end of the string.
						* Subtracting from the string iterator moves toward the
						* start of the string.
						*/
						ItForward_t	= 'F',

						/**
						* ItReverse_t The iterator moves in reverse. Adding to the
						* string iterator moves toward the start of the string.
						* Subtracting from the string iterator moves toward the
						* end of the string.
						*/
						ItReverse_t	= 'R'
					};

					/**
					 * @class iteratorType String.hpp "<SaS/String/String.hpp>"
					 * An iterator for a specific type of string for the String object.
					 *
					 * An iterator for characters in a String. Mostly used
					 * by ROString as ROString may not have a terminating zero
					 * at the end of its strings.
					 */
					class const_iterator;
					template <typename T>
					class iteratorType {
						public:
							friend class String;

							typedef iteratorType		self_type;
							typedef const iteratorType		cself_type;
							typedef const T		value_type;
							typedef const T	&	reference;
							typedef const T	*	pointer;
							typedef std::random_access_iterator_tag	iterator_category;
							typedef int64_t		difference_type;

							/**
							 * iteratorType: Current Constructor.
							 *
							 * Initialzed to nothing.
							 */
							iteratorType() {
								_First = nullptr;
								_Ptr = nullptr;
								_Last = nullptr;

								return;
							}

							/**
							 * iteratorType: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							iteratorType(pointer Ptr, size_t Len) {
								_First = Ptr;
								_Ptr = Ptr;
								_Last = _Ptr + Len - 1;

								return;
							}

							/**
							 * iteratorType: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							iteratorType(pointer Start, pointer Ptr, size_t Len) {
								_First = Start;
								_Ptr = Ptr;
								_Last = Start + Len - 1;

								return;
							}

							/**
							 * iteratorType:: Copy Constructor.
							 *
							 * @param CopyFrom the iteratorType to copy from.
							 */
							iteratorType(const self_type & CopyFrom) {
								_First = CopyFrom._First;
								_Ptr = CopyFrom._Ptr;
								_Last = CopyFrom._Last;

								return;
							}

							/**
							 * iteratorType: Copy operator.
							 *
							 * @param Other Copy Other to a new iteratorType.
							 *
							 * @return (*this) updated.
							 */
							self_type
							operator=(const self_type & Other) {
								_First = Other._First;
								_Ptr = Other._Ptr;
								_Last = Other._Last;

								return (*this);
							}

							/**
							 * iteratorType: Move forward operator - prefix.
							 * This operator will not increment past end().
							 * Moves forward by character width.
							 *
							 * @return After incrementing the self_type iterator,
							 * it returns the newly updated iterator.
							 */
							self_type
							operator++() {

								_Ptr++;

								if (_Ptr > _Last) {
									_Ptr = _Last;
								}

								return (*this);
							}

							/**
							 * iteratorType: Move forward operator - postfix.
							 * This operator will not increment past end().
							 * Moves forward by character width.
							 *
							 * @return the iteratorType to the current position.
							 * Then increments to the next character width position.
							 */
							self_type
							operator++(int /*NOTUSED*/) {
								self_type	&	Results(*this);

								_Ptr++;

								if (_Ptr > _Last) {
									_Ptr = _Last;
								}

								return (Results);
							}

							/**
							 * iteratorType: Move backward operator - prefix.
							 * This operator will not decrement before begin().
							 * Moves backward by character width.
							 *
							 * @return After incrementing the self_type iterator,
							 * it returns the updated iterator.
							 * Does not go before begin().
							 */
							self_type
							operator--() {

								_Ptr--;

								if (_Ptr < _First) {
									_Ptr = _First;
								}

								return (*this);
							}

							/**
							 * iteratorType: Move backward operator - postfix
							 * This operator will not decrement before begin().
							 * Moves backward by character width.
							 *
							 * @return the current iterator, then updates to the next
							 * character. Does not back up before begin().
							 */
							self_type
							operator--(int /*NOTUSED*/) {
								self_type	Results(*this);

								_Ptr--;

								if (_Ptr < _First) {
									_Ptr = _First;
								}

								return (Results);
							}

							/**
							 * iteratorType: Move forward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 *
							 * @param Add How many character widths to add to
							 * iterator. Moves forward by character width.
							 * Or if negative, backward.
							 *
							 * @return A new self_type iterator up to Add characters
							 * forward of the current position.
							 * Does not go past begin() or end().
							 */
							self_type
							operator+(int64_t Add) const {
								self_type	Results(*this);

								if (Add > 0) {
									Results._Ptr += Add;

									if (Results._Ptr > Results._Last) {
										Results._Ptr = Results._Last;
									}

								} else if (Add < 0) {
									Results._Ptr += Add;

									if (Results._Ptr < Results._First) {
										Results._Ptr = Results._First;
									}
								}

								return (Results);
							}

							/**
							 * iteratorType: Move forward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 *
							 * @param Add How many positions to add (or subtract)
							 * from iterator.
							 * Moves forward by character position, not by octet,
							 * and not by character unit width.
							 *
							 * @return (*this) updated to Add characters forward.
							 * Does not go past end().
							 */
							self_type	&
							operator+=(int64_t Add) {
								*this = (*this + Add);

								return (*this);
							}

							/**
							 * iteratorType: Move backward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 * This method backward by character width units.
							 *
							 * @param Sub How many character width objects to subtract.
							 * Or if negative, add.
							 *
							 * @return Backup Sub characters and return the new
							 * self_type iterator. Does not backup before begin()
							 * or after end().
							 */
							self_type
							operator-(int64_t Sub) const {
								self_type	Results(*this);

								if (Sub < 0) {
									Results._Ptr += Sub;

									if (Results._Ptr > Results._Last) {
										Results._Ptr = Results._Last;
									}

								} else if (Sub > 0) {
									Results._Ptr -= Sub;

									if (Results._Ptr > Results._First) {
										Results._Ptr = Results._First;
									}
								}

								return (Results);
							}

							/**
							 * iteratorType: Move backward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 * This method backward by character width units.
							 *
							 * @param Sub How many positions to subtract (or add)
							 * from iterator.
							 *
							 * @return Backup Sub characters and return (*this).
							 * Does not backup before begin().
							 */
							self_type	&
							operator-=(int64_t Sub) {
								*this = (*this - Sub);

								return (*this);
							}

							/**
							 * iteratorType: std::distance() operator.
							 * Get the difference between two iterators.
							 *
							 * @param Other The other iterator to compare to.
							 *
							 * @return The difference between the two iterators
							 * in chracter units (not characters or octets).
							 */
							int64_t
							operator-(self_type & Other) {
								int64_t		Results = _Ptr - Other._Ptr;

								return (Results);
							}

							/**
							 * iteratorType: < compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return true when the current character position
							 * is before the Rsh character position in the string.
							 */
							bool
							operator<(const self_type & Rhs) {
								bool		Results = false;

								if (_Ptr != nullptr && Rhs._Ptr != nullptr) {
									if (_Ptr < Rhs._Ptr) {
										Results = true;
									}

								} else if (_Ptr == nullptr && Rhs._Ptr != nullptr) {
									Results = true;
								}

								return (Results);
							}

							/**
							 * iteratorType: > compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return true when the current character position
							 * is after the Rsh character position in the string.
							 */
							bool
							operator>(const self_type & Rhs) {
								bool		Results = false;

								if (_Ptr != nullptr && Rhs._Ptr != nullptr) {
									if (_Ptr > Rhs._Ptr) {
										Results = true;
									}

								} else if (_Ptr != nullptr && Rhs._Ptr == nullptr) {
									Results = true;
								}

								return (Results);
							}

							/**
							 * iteratorType: <= compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return true when the current character position
							 * is before or the same as the Rsh character position
							 * in the string.
							 */
							bool
							operator<=(const self_type & Rhs) {
								bool		Results = false;

								if (_Ptr != nullptr && Rhs._Ptr != nullptr) {
									if (_Ptr <= Rhs._Ptr) {
										Results = true;
									}

								} else if (_Ptr != nullptr && Rhs._Ptr == nullptr) {
									Results = true;
								}

								return (Results);
							}

							/**
							 * iteratorType: >= compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return true when the current character position
							 * is after or the same as the Rsh character position
							 * in the string.
							 */
							bool
							operator>=(const self_type & Rhs) {
								bool		Results = false;

								if (_Ptr != nullptr && Rhs._Ptr != nullptr) {
									if (_Ptr >= Rhs._Ptr) {
										Results = true;
									}

								} else if (_Ptr != nullptr && Rhs._Ptr == nullptr) {
									Results = true;
								}

								return (Results);
							}

							/**
							 * iteratorType: inderection operator.
							 *
							 * @return the value of (this) iterator. Get the character.
							 */
							inline reference
							operator*() const {
								return (*_Ptr);
							}

							/**
							 * iteratorType: value of pointer.
							 *
							 * @return the value of the pointer to the current character.
							 */
							inline pointer
							operator->() const {
								return (_Ptr);
							}

							/**
							 * iteratorType: value of pointer.
							 *
							 * @return the value of the pointer to the current character.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							inline pointer
							str() const {
								return (_Ptr);
							}

							/**
							 * iteratorType: == compare operator.
							 *
							 * @param Rhs Compare (*this) to Rhs.
							 *
							 * @return true when (*this) is equal to Rhs.
							 */
							inline bool
							operator==(const self_type & Rhs) const {
								return (_Ptr == Rhs._Ptr);
							}

							/**
							 * iteratorType: != compare operator.
							 *
							 * @param Rhs Compare (*this) to Rhs.
							 *
							 * @return true when (*this) is not equal to Rhs.
							 */
							inline bool
							operator!=(const self_type & Rhs) const {
								return (_Ptr != Rhs._Ptr);
							}

							/**
							 * iteratorType: Random access dereference operator.
							 * Get the position for the desired character.
							 *
							 * @param Offset Which position to get.
							 * Values over end() will be truncated to end().
							 *
							 * @return An iterator at the named postion.
							 *
							 * @note
							 * Because of multibyte character sets UTF-8 and
							 * UTF-16, this method has to start at the beginning of the
							 * string and increment to the correct position.
							 *
							 * With UTF-32, it is a direct offset.
							 */
							self_type
							operator[](size_t Offset) const {
								self_type	Results(*this);

								if (std::is_same<T, char32_t>::value) {
									if (Results->_First + Offset < _Last) {
										Results->_Ptr = Results->_First + Offset;

									} else {
										String::iteratorType<T>::Results->_Ptr = Results->_Last;
									}

								} else {
									size_t	Position = 0;

									Results->_Ptr = Results->_First;

									while (Position++ < Offset) {
										Results++;
									}
								}

								return (Results);
							}

							/**
							 * An iterator to the first character in the string.
							 *
							 * @return An iterator to the first character in the string.
							 */
							self_type				&
							begin() {
								self_type	&	Results(*this);

								Results->_Ptr = Results->_First;

								return (Results);
							}

							/**
							 * And iterator to the last character in the string.
							 * Not all strings end with a zero. This returns the
							 * last character in the string.
							 *
							 * @return an iterator to the last character in the string.
							 */
							self_type				&
							rbegin() {
								self_type	&	Results(*this);

								Results->_Ptr = Results->_Last;

								return (Results);
							}

							/**
							 * An iterator to the first character in the string.
							 *
							 * @return A const iterator to the first character in the string.
							 */
							const self_type	&
							cbegin() {
								const self_type	&	Results(*this);

								Results->_Ptr = Results->_First;

								return (Results);
							}

							/**
							 * Point to the last character in the string.
							 * Not all strings are zero terminated.
							 *
							 * @return The iterator to the last character in the string.
							 */
							const self_type	&
							crbegin() {
								const self_type	&	Results(*this);

								Results->_Ptr = Results->_Last;
								Results->_Ptr++;	// Point to zero.

								return (Results);
							}

							/**
							 * Point to the last character in the string.
							 * Not all strings are zero terminated.
							 *
							 * @return The iterator to the last character in the string.
							 */
							self_type	&
							end() {
								self_type	&	Results(*this);

								Results->_Ptr = Results->_Last;

								return (Results);
							}

							/**
							 * An iterator to the first character in the string.
							 *
							 * @return An iterator to the first character in the string.
							 */
							self_type	&
							rend() {
								self_type	&	Results(*this);

								Results->_Ptr = Results->_First;

								return (Results);
							}

							/**
							 * Point to the last character in the string.
							 * Not all strings are zero terminated.
							 *
							 * @return  iterator to the last character in the string.
							 */
							cself_type	&
							cend() {
								cself_type	& Results(*this);

								Results->_Ptr = Results->_Last;

								return (Results);
							}

							cself_type	&
							crend() {
								cself_type	& Results(*this);

								Results->_Ptr = Results->_First;

								return (Results);
							}

						private:

							/**
							 * pointer to the first character in the String.
							 */
							pointer	_First;

							/**
							 * Current iterator position.
							 */
							pointer	_Ptr;

							/**
							 * pointer to the first position after the last
							 * character in the String.
							 */
							pointer	_Last;
					};

					/**
					 * @class const_iteratorType String.hpp "<SaS/String/String.hpp>"
					 * An iterator for a specific type of string for the String object.
					 *
					 * An const_iterator for characters in a String. Mostly used
					 * by ROString as ROString may not have a terminating zero
					 * at the end of its strings.
					 */
					class const_iterator;
					template <typename T>
					class const_iteratorType {
						public:

							typedef const const_iteratorType		self_type;
							typedef const T		value_type;
							typedef const T	&	reference;
							typedef const T	*	pointer;
							typedef std::random_access_iterator_tag	iterator_category;
							typedef int64_t		difference_type;

							/**
							 * const_iteratorType: Current Constructor.
							 *
							 * Initialzed to nothing.
							 */
							const_iteratorType() {
								_First = nullptr;
								_Ptr = nullptr;
								_Last = nullptr;

								return;
							}

							/**
							 * const_iteratorType: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iteratorType(pointer Ptr, size_t Len) {
								_First = Ptr;
								_Ptr = Ptr;
								_Last = _Ptr + Len - 1;

								return;
							}

							/**
							 * const_iteratorType: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the const_iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iteratorType(pointer Start, pointer Ptr, size_t Len) {
								_First = Start;
								_Ptr = Ptr;
								_Last = Start + Len - 1;

								return;
							}

							/**
							 * const_iteratorType:: Copy Constructor.
							 *
							 * @param CopyFrom the iteratorType to copy from.
							 */
							const_iteratorType(const self_type & CopyFrom) {
								_First = CopyFrom._First;
								_Ptr = CopyFrom._Ptr;
								_Last = CopyFrom._Last;

								return;
							}

							/**
							 * const_iteratorType: Copy operator.
							 *
							 * @param Other Copy Other to (*this).
							 *
							 * @return (*this) updated.
							 */
							self_type
							operator=(const self_type & Other) {
								_First = Other._First;
								_Ptr = Other._Ptr;
								_Last = Other._Last;

								return (*this);
							}

							/**
							 * const_iteratorType: Copy operator.
							 *
							 * @param Other Copy Other to (*this).
							 *
							 * @return (*this) updated.
							 */
							self_type
							operator=(const iteratorType<T> & Other) {
								_First = Other._First;
								_Ptr = Other._Ptr;
								_Last = Other._Last;

								return (*this);
							}

							/**
							 * const_iteratorType: Move forward operator - prefix.
							 * This operator will not increment past end().
							 * Moves forward by character, not by octet,
							 * and not by character unit width.
							 */
							self_type
							operator++() {

								_Ptr++;

								if (_Ptr > _Last) {
									_Ptr = _Last;
								}

								return (*this);
							}

							/**
							 * const_iteratorType: Move forward operator - postfix.
							 * This operator will not increment past end().
							 * Moves forward by character, not by octet,
							 * and not by character unit width.
							 */
							self_type
							operator++(int /*NOTUSED*/) {
								self_type	Results(*this);

								_Ptr++;

								if (_Ptr > _Last) {
									_Ptr = _Last;
								}

								return (Results);
							}

							/**
							 * const_iteratorType: Move backward operator - prefix.
							 * This operator will not decrement before begin().
							 * Moves backward by character, not by octet,
							 * and not by character unit width.
							 */
							self_type
							operator--() {

								_Ptr--;

								if (_Ptr < _First) {
									_Ptr = _First;
								}

								return (*this);
							}

							/**
							 * const_iteratorType: Move backward operator - postfix
							 * This operator will not decrement before begin().
							 * Moves backward by character, not by octet,
							 * and not by character unit width.
							 */
							self_type
							operator--(int /*NOTUSED*/) {
								self_type	Results(*this);

								_Ptr--;

								if (_Ptr < _First) {
									_Ptr = _First;
								}

								return (Results);
							}

							/**
							 * const_iteratorType: Move forward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 * Or if negative, backwards.
							 *
							 * @param Add How many positions to subtract (or add)
							 * from const_iterator.
							 * Moves forward by character position, not by octet,
							 * and not by character unit width.
							 *
							 * @return New updated const_iterator. Does not go
							 * past begin() or end().
							 */
							self_type
							operator+(int64_t Add) const {
								self_type	Results(*this);

								if (Add > 0) {
									_Ptr += Add;

									if (_Ptr > _Last) {
										_Ptr = _Last;
									}

								} else if (Add < 0) {
									_Ptr += Add;

									if (_Ptr < _First) {
										_Ptr = _First;
									}
								}

								return (Results);
							}

							/**
							 * const_iteratorType: Move forward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 *
							 * @param Add How many positions to add (or subtract)
							 * from const_iterator.
							 * Moves forward by character position, not by octet,
							 * and not by character unit width.
							 *
							 * @return (*this) updated.
							 */
							self_type	&
							operator+=(int64_t Add) {
								*this = (*this + Add);

								return (*this);
							}

							/**
							 * const_iteratorType: Move backward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 * This method backward by character width units.
							 * Or if negative, add.
							 *
							 * @param Sub How many positions to subtract (or add)
							 * from const_iterator.
							 * @return New updated const_iterator.
							 * Does not backup before begin() or after end().
							 */
							self_type
							operator-(int64_t Sub) const {
								self_type	Results(*this);

								if (Sub > 0) {
									Results->_Ptr -= Sub;

									if (Results->_Ptr < Results->_First) {
										Results->_Ptr = Results->_First;
									}

								} else if (Sub < 0) {
									Results->_Ptr += Sub;

									if (Results->_Ptr < Results->_Last) {
										Results->_Ptr = Results->_Last;
									}
								}

								return (Results);
							}

							/**
							 * const_iteratorType: Move backward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 * This method backward by character width units.
							 *
							 * @param Sub How many positions to subtract (or add)
							 * from const_iterator.
							 *
							 * @return (*this) updated.
							 */
							self_type	&
							operator-=(int64_t Sub) {
								*this = (*this - Sub);

								return (*this);
							}

							/**
							 * const_iteratorType: std::distance() operator.
							 * Get the difference between two const_iterators.
							 *
							 * @param Other The other const_iterator to compare to.
							 *
							 * @return The difference between the two const_iterators
							 * in chracter units (not characters or octets).
							 */
							int64_t
							operator-(self_type Other) {
								int64_t		Results = _Ptr - Other._Ptr;

								return (Results);
							}

							/**
							 * const_iteratorType: < compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return true when the current character position
							 * is before the Rsh character position
							 * in the string.
							 */
							bool
							operator<(const self_type & Rhs) {
								bool		Results = false;

								if (_Ptr != nullptr && Rhs._Ptr != nullptr) {
									if (_Ptr < Rhs._Ptr) {
										Results = true;
									}

								} else if (_Ptr == nullptr && Rhs._Ptr != nullptr) {
									Results = true;
								}

								return (Results);
							}

							/**
							 * const_iteratorType: > compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return true when the current character position
							 * is after the Rsh character position
							 * in the string.
							 */
							bool
							operator>(const self_type & Rhs) {
								bool		Results = false;

								if (_Ptr != nullptr && Rhs._Ptr != nullptr) {
									if (_Ptr > Rhs._Ptr) {
										Results = true;
									}

								} else if (_Ptr != nullptr && Rhs._Ptr == nullptr) {
									Results = true;
								}

								return (Results);
							}

							/**
							 * const_iteratorType: <= compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return true when the current character position
							 * is before or the same as the Rsh character position
							 * in the string.
							 */
							bool
							operator<=(const self_type & Rhs) {
								bool		Results = false;

								if (_Ptr != nullptr && Rhs._Ptr != nullptr) {
									if (_Ptr <= Rhs._Ptr) {
										Results = true;
									}

								} else if (_Ptr != nullptr && Rhs._Ptr == nullptr) {
									Results = true;
								}

								return (Results);
							}

							/**
							 * const_iteratorType: >= compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return true when the current character position
							 * is after or the same as the Rsh character position
							 * in the string.
							 */
							bool
							operator>=(const self_type & Rhs) {
								bool		Results = false;

								if (_Ptr != nullptr && Rhs._Ptr != nullptr) {
									if (_Ptr >= Rhs._Ptr) {
										Results = true;
									}

								} else if (_Ptr != nullptr && Rhs._Ptr == nullptr) {
									Results = true;
								}

								return (Results);
							}

							/**
							 * const_iteratorType: inderection operator.
							 *
							 * @return the value of (this) const_iterator. Get the character.
							 */
							inline reference
							operator*() const {
								return (*_Ptr);
							}

							/**
							 * const_iteratorType: value of pointer.
							 *
							 * @return the value of the pointer to the current character.
							 */
							inline pointer
							operator->() const {
								return (_Ptr);
							}

							/**
							 * const_iteratorType: value of pointer.
							 *
							 * @return the value of the pointer to the current character.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							inline pointer
							str() const {
								return (_Ptr);
							}

							/**
							 * const_iteratorType: == compare operator.
							 *
							 * @param Rhs Compare (*this) to Rhs.
							 *
							 * @return true when (*this) is equal to Rhs.
							 */
							inline bool
							operator==(const self_type & Rhs) const {
								return (_Ptr == Rhs._Ptr);
							}

							/**
							 * const_iteratorType: != compare operator.
							 *
							 * @param Rhs Compare (*this) to Rhs.
							 *
							 * @return true when (*this) is not equal to Rhs.
							 */
							inline bool
							operator!=(const self_type & Rhs) const {
								return (_Ptr != Rhs._Ptr);
							}

							/**
							 * const_iteratorType: Random access dereference operator.
							 * Get the position for the desired character.
							 *
							 * @param Offset Which position to get.
							 * Values over end() will be truncated to end().
							 *
							 * @return An const_iterator at the named postion.
							 *
							 * @note
							 * Because of multibyte character sets UTF-8 and
							 * UTF-16, this method has to start at the beginning of the
							 * string and increment to the correct position.
							 *
							 * With UTF-32, it is a direct offset.
							 */
							self_type
							operator[](size_t Offset) const {
								self_type	Results(*this);

								if (std::is_same<T, char32_t>::value) {
									if (Results->_First + Offset < _Last) {
										Results->_Ptr = Results->_First + Offset;

									} else {
										String::const_iteratorType<T>::Results->_Ptr =
										    Results->_Last;
									}

								} else {
									size_t	Position = 0;

									Results->_Ptr = Results->_First;

									while (Position++ < Offset) {
										Results++;
									}
								}

								return (Results);
							}

							self_type	&
							begin() {
								self_type	&	Results(*this);

								Results->_Ptr = Results->_First;

								return (Results);
							}

							self_type	&
							rbegin() {
								self_type	&	Results(*this);

								Results->_Ptr = Results->_Last;

								return (Results);
							}

							self_type	&
							end() {
								self_type	& Results(*this);

								Results->_Ptr = Results->_Last;

								return (Results);
							}

							self_type	&
							rend() {
								self_type	& Results(*this);

								Results->_Ptr = Results->_First;

								return (Results);
							}

						private:

							/**
							 * pointer to the first character in the String.
							 */
							pointer	_First;

							/**
							 * Current const_iterator position.
							 */
							pointer	_Ptr;

							/**
							 * pointer to the first position after the last
							 * character in the String.
							 */
							pointer	_Last;
					};

					/**
					 * @class IteratorBase
					 */
					class IteratorBase {
						public:

							/**
							 * Determine if this iterator is const_ type.
							 *
							 * @return true when this object is a const_iterator,
							 * and false when this object is <b>not</b> a const_iterator.
							 */
							virtual bool				IsConstIterator() const = 0;

							/**
							 * Determine if this iterator is ItForward_t or IsReverse_t.
							 *
							 * @return ItForward_t or ItReverse_t
							 */
							inline IteratorDirection
							Direction() const {
								return (_Direction);
							}

						protected:

							/**
							 * When true, this iterator is a const_ iterator.
							 */
							bool								_IsConst;

							/**
							 * The direction of the increment.
							 * When 'R' is it a reverse iterator.
							 * When 'F' is it a forward iterator.
							 */
							IteratorDirection		_Direction;
							/**
							 * Increment *this by CharCount characters.
							 * DO NOT call this private method with a negative number.
							 *
							 * @param CharCount The number of characters to increment.
							 */
							void					_Inc(int64_t CharCount);

							/**
							 * Decrement *this by CharCount characters.
							 * DO NOT call this private method with a negative number.
							 *
							 * @param CharCount The number of characters to decrement.
							 */
							void					_Dec(int64_t CharCount);

							/**
							 * The width of the character for this iterator.
							 */
							CharacterUnitWidth_e	_Width;

							/**
							 * The character type specific iterator.
							 */
							union {
								iteratorType<char>		*	It8;
								iteratorType<char16_t>	*	It16;
								iteratorType<char32_t>	*	It32;
								iteratorType<wchar_t>	*	ItW;
							} _It;
					};

					/**
					 * @class iterator String.hpp "<SaS/String/String.hpp>"
					 * An iterator for the contents of a String object.
					 *
					 * An iterator for String and ROString values.
					 */
					class const_iterator;
					class iterator
						: public IteratorBase {
						public:
							friend class String;

							typedef iterator			self_type;
							typedef const_iterator			cself_type;
							typedef char32_t			value_type;
							typedef char32_t		&	reference;
							typedef const void		*	pointer;
							typedef std::random_access_iterator_tag	iterator_category;
							typedef int64_t		difference_type;

							/**
							 * iterator: Current Constructor.
							 * Currents to 8-bit strings.
							 *
							 * Initialzed to nothing.
							 */
							iterator();

							/**
							 * iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 *
							 * @param Width The character width.
							 */
							iterator(pointer Ptr, size_t Len,
							         CharacterUnitWidth_e Width);


							/**
							 * iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							iterator(const char * Ptr, size_t Len);

							/**
							 * iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							iterator(const char16_t * Ptr, size_t Len);

							/**
							 * iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							iterator(const char32_t * Ptr, size_t Len);

							/**
							 * iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							iterator(const wchar_t * Ptr, size_t Len);

							/**
							 * iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 *
							 * @param Width The character width.
							 */
							iterator(pointer Start,
							         pointer Ptr,
							         size_t Len,
							         CharacterUnitWidth_e Width);

							/**
							 * iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 *
							 * @param Width The character width.
							 */
							iterator(const char * Start,
							         const char * Ptr,
							         size_t Len);

							/**
							 * iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 *
							 * @param Width The character width.
							 */
							iterator(const char16_t * Start,
							         const char16_t * Ptr,
							         size_t Len);

							/**
							 * iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 *
							 * @param Width The character width.
							 */
							iterator(const char32_t * Start,
							         const char32_t * Ptr,
							         size_t Len);

							/**
							 * iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 *
							 * @param Width The character width.
							 */
							iterator(const wchar_t * Start,
							         const wchar_t * Ptr,
							         size_t Len);

							/**
							 * iterator: Copy Constructor.
							 *
							 * @param CopyFrom the iteratorType to copy from.
							 */
							iterator(const self_type & CopyFrom);

							/**
							 * Determine if this iterator is const_ type.
							 */
							virtual bool
							IsConstIterator() const {
								return (false);
							};

							/**
							 * Get the width of this iterator.
							 *
							 * @return The CharacterUnitWidth_e type for the contents.
							 */
							CharacterUnitWidth_e	Width() const;

							/**
							 * iterator: Copy operator.
							 *
							 * @param Other Copy Other to (*this).
							 *
							 * @return (*this) updated.
							 */
							self_type	  operator=(const self_type & Other);

							/**
							 * iterator: Move forward operator - prefix.
							 * This operator will not increment past end().
							 * Moves forward by character, not by octet,
							 * and not by character unit width.
							 */
							self_type	 operator++();

							/**
							 * iterator: Move forward operator - postfix.
							 * This operator will not increment past end().
							 * Moves forward by character, not by octet,
							 * and not by character unit width.
							 */
							self_type	 operator++(int /*NOTUSED*/);

							/**
							 * iterator: Move backward operator - prefix.
							 * This operator will not decrement before begin().
							 * Moves backward by character, not by octet,
							 * and not by character unit width.
							*
							* @note
							* As some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values).
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	 operator--();

							/**
							 * iterator: Move backward operator - postfix
							 * This operator will not decrement before begin().
							 * Moves backward by character, not by octet,
							 * and not by character unit width.
							*
							* @note
							* As some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values).
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	 operator--(int /*NOTUSED*/);

							/**
							 * iterator: Move forward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 *
							 * @param Add How many positions to subtract (or add)
							 * from iterator.
							 * Moves forward by character position, not by octet,
							 * and not by character unit width.
							 * Or if negative, backwards.
							 *
							 * @return New updated iterator. Does not got past begi()
							 * or end().
							*
							* @note
							* When Add is negative, and some character sets are variable
							* length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values).
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	  operator+(int64_t Add) const;

							/**
							 * iterator: Move forward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 *
							 * @param Add How many positions to add (or subtract)
							 * from iterator.
							 * Moves forward by character position, not by octet,
							 * and not by character unit width.
							 *
							 * @return (*this) updated.
							*
							* @note
							* When Add is negative,
							* and some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values).
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	 &  operator+=(int64_t Add);

							/**
							 * iterator: Move backward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 * Moves backward by character position, not by octet,
							 * and not by character unit width.
							 *
							 * @param Sub How many positions to subtract (or add)
							 * from iterator.
							 * Or if negative, add.
							 *
							 * @return New updated iterator. Does not go past begin()
							 * or end().
							*
							* @note
							* As some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup Sub characters (which may be multiple character width
							* values). Depending on the characters, it may have to
							* repeat this loop Sub times.
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	  operator-(int64_t Sub) const;

							/**
							 * iterator: Move backward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 * Moves backward by character position, not by octet,
							 * and not by character unit width.
							 *
							 * @param Sub How many positions to subtract (or add)
							 * from iterator.
							 *
							 * @return (*this) updated.
							*
							* @note
							* As some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values). Depending on the characters, it may have to
							* repeat this loop Sub times.
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	 &  operator-=(int64_t Sub);

							/**
							 * iterator: std::distance() operator.
							 * Get the difference between two iterators.
							 *
							 * @param Other The other iterator to compare to.
							 *
							 * @return The difference between the two iterators
							 * in chracter units (not characters or octets).
							 */
							int64_t	  operator-(self_type Other);

							/**
							 * iterator: < compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return For forward iterators:
							 * - Returns true when the current character position
							 * is before the Rsh character position
							 * in the string.
							 *
							 *  For reverse iterators:
							 * - Returns true when the current character position
							 * is after the Rsh character position
							 * in the string.
							 */
							bool	  operator<(const self_type & Rhs);

							/**
							 * iterator: > compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return For forward iterators:
							 * - Returns true when the current character position
							 * is after the Rsh character position
							 * in the string.
							 *
							 *  For reverse iterators:
							 * - Returns true when the current character position
							 * is before the Rsh character position
							 * in the string.
							 */
							bool	  operator>(const self_type & Rhs);

							/**
							 * iterator: <= compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return For forward iterators:
							 * - Returns true when the current character position
							 * is before or the same as the Rsh character position
							 * in the string.
							 *
							 *  For reverse iterators:
							 * - Returns true when the current character position
							 * is after or same as the Rsh character position
							 * in the string.
							 */
							bool	  operator<=(const self_type & Rhs);

							/**
							 * iterator: >= compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return For forward iterators:
							 * - Returns true when the current character position
							 * is after or the same as the Rsh character position
							 * in the string.
							 *
							 *  For reverse iterators:
							 * - Returns true when the current character position
							 * is before or same as the Rsh character position
							 * in the string.
							 */
							bool	  operator>=(const self_type & Rhs);

							/**
							 * iterator: inderection operator.
							 *
							 * @return the value of (this) iterator. Get the character.
							 */
							reference	  operator*() const;

							/**
							 * iterator: value of pointer.
							 *
							 * @return the value of the pointer to the current character.
							 */
							pointer	  operator->() const;

							/**
							 * iterator: value of pointer (to any (char*)value.
							 *
							 * @return the value of the pointer to the current character.
							 * Returns nullptr when Width() is not Is8Bit_t.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							const char		*  str8() const;

							/**
							 * iterator: value of pointer (to any (char16_t*)value.
							 *
							 * @return the value of the pointer to the current character.
							 * Returns nullptr when Width() is not Is16Bit_t.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							const char16_t		*  str16() const;

							/**
							 * iterator: value of pointer (to any (char32_t*)value.
							 *
							 * @return the value of the pointer to the current character.
							 * Returns nullptr when Width() is not Is32Bit_t.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							const char32_t		*  str32() const;

							/**
							 * iterator: value of pointer (to any (wchar_t*)value.
							 *
							 * @return the value of the pointer to the current character.
							 * Returns nullptr when Width() is not IsWBit_t.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							const wchar_t		*  strW() const;

							/**
							 * iterator: == compare operator.
							 *
							 * @param Rhs Compare (*this) to Rhs.
							 *
							 * @return true when (*this) is equal to Rhs.
							 */
							bool	  operator==(const self_type & Rhs) const;

							/**
							 * iterator: != compare operator.
							 *
							 * @param Rhs Compare (*this) to Rhs.
							 *
							 * @return true when (*this) is not equal to Rhs.
							 */
							bool	  operator!=(const self_type & Rhs) const;

							/**
							 * iterator: Random access dereference operator.
							 * Get the position for the desired character.
							 *
							 * @param Offset Which position to get.
							 * Values over end() will be truncated to end().
							 *
							 * @return An iterator at the named postion.
							 *
							 * @note
							 * Because of multibyte character sets UTF-8 and
							 * UTF-16, this method has to start at the beginning of the
							 * string and increment to the correct position.
							 *
							 * With UTF-32, it is a direct offset.
							 */
							self_type	  operator[](size_t Offset) const;

						private:

							friend class String;
							friend class ROString;
					};

					/**
					 * @class const_iterator String.hpp "<SaS/String/String.hpp>"
					 * A const_iterator for the contents of a String object.
					 *
					 * An const_iterator for String and ROString values.
					 */
					class const_iterator
						: public IteratorBase {
						public:

							typedef const_iterator		self_type;
							typedef const char32_t		value_type;
							typedef char32_t		&	reference;
							typedef const void		*	pointer;
							typedef std::random_access_iterator_tag	iterator_category;
							typedef int64_t		difference_type;

							/**
							 * const_iterator: Current Constructor.
							 * Currents to 8-bit strings.
							 *
							 * Initialzed to nothing.
							 */
							const_iterator();

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 *
							 * @param Width The character width.
							 */
							const_iterator(pointer Ptr,
							               size_t Len,
							               CharacterUnitWidth_e Width);

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iterator(const char * Ptr,
							               size_t Len);

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iterator(const char16_t * Ptr,
							               size_t Len);

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iterator(const char32_t * Ptr,
							               size_t Len);

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Ptr Point to start of string.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iterator(const wchar_t * Ptr,
							               size_t Len);

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 *
							 * @param Width The character width.
							 */
							const_iterator(pointer Start,
							               pointer Ptr,
							               size_t Len,
							               CharacterUnitWidth_e Width);

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iterator(const char * Start,
							               const char * Ptr,
							               size_t Len);

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iterator(const char16_t * Start,
							               const char16_t * Ptr,
							               size_t Len);

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iterator(const char32_t * Start,
							               const char32_t * Ptr,
							               size_t Len);

							/**
							 * const_iterator: Constructor.
							 *
							 * @param Start Point to start of string.
							 *
							 * @param Ptr Where the iterator should point to.
							 *
							 * @param Len The number of character units in Ptr.
							 */
							const_iterator(const wchar_t * Start,
							               const wchar_t * Ptr,
							               size_t Len);

							/**
							 * const_iterator: Copy Constructor.
							 *
							 * @param CopyFrom the iteratorType to copy from.
							 */
							const_iterator(const self_type & CopyFrom);

							/**
							 * const_iterator: Copy Constructor.
							 *
							 * @param CopyFrom the iteratorType to copy from.
							 */
							const_iterator(const iterator & CopyFrom);

							/**
							 * Determine if this iterator is const_ type.
							 */
							virtual bool
							IsConstIterator() const {
								return (true);
							};

							/**
							 * Get the width of this iterator.
							 *
							 * @return The CharacterUnitWidth_e type for the contents.
							 */
							CharacterUnitWidth_e	Width() const;

							/**
							 * const_iterator: Copy operator.
							 *
							 * @param Other Copy Other to (*this).
							 *
							 * @return (*this) updated.
							 */
							self_type	  operator=(const self_type & Other);

							/**
							 * iterator: Move forward operator - prefix.
							 * This operator will not increment past end().
							 * Moves forward by character, not by octet,
							 * and not by character unit width.
							 */
							self_type	 operator++();

							/**
							 * iterator: Move forward operator - postfix.
							 * This operator will not increment past end().
							 * Moves forward by character, not by octet,
							 * and not by character unit width.
							 */
							self_type	 operator++(int /*NOTUSED*/);

							/**
							 * iterator: Move backward operator - prefix.
							 * This operator will not decrement before begin().
							 * Moves backward by character, not by octet,
							 * and not by character unit width.
							*
							* @note
							* As some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values).
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	 operator--();

							/**
							 * iterator: Move backward operator - postfix
							 * This operator will not decrement before begin().
							 * Moves backward by character, not by octet,
							 * and not by character unit width.
							*
							* @note
							* As some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values).
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	 operator--(int /*NOTUSED*/);

							/**
							 * iterator: Move forward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 *
							 * @param Add How many positions to subtract (or add)
							 * from iterator.
							 * Moves forward by character position, not by octet,
							 * and not by character unit width.
							 * Or if negative, backwards.
							 *
							 * @return New updated iterator. Does not go past begin()
							 * or end().
							*
							* @note
							* When Add is negative, and
							* as some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values). Depending on the characters, it may have to
							* repeat this loop Sub times.
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	  operator+(int64_t Add) const;

							/**
							 * iterator: Move forward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 *
							 * @param Add How many positions to add (or subtract)
							 * from iterator.
							 * Moves forward by character position, not by octet,
							 * and not by character unit width.
							 *
							 * @return (*this) updated.
							*
							* @note
							* When Add is negative and,
							* as some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values). Depending on the characters, it may have to
							* repeat this loop Sub times.
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	 &  operator+=(int64_t Add);

							/**
							 * iterator: Move backward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 * Moves backward by character position, not by octet,
							 * and not by character unit width.
							 * Or if negative, add.
							 *
							 * @param Sub How many positions to subtract (or add)
							 * from iterator.
							 *
							 * @return New updated iterator. Does not go past begin()
							 * or end().
							*
							* @note
							* As some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values). Depending on the characters, it may have to
							* repeat this loop Sub times.
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							self_type	  operator-(int64_t Sub) const;

							/**
							 * iterator: Move backward operator.
							 * This operator will not decrement before begin().
							 * This operator will not increment after end().
							 * Moves backward by character position, not by octet,
							 * and not by character unit width.
							 *
							 * @param Sub How many positions to subtract (or add)
							 * from iterator.
							 *
							 * @return (*this) updated.
							 */
							self_type	 &  operator-=(int64_t Sub);

							/**
							 * iterator: std::distance() operator.
							 * Get the difference between two iterators.
							 *
							 * @param Other The other iterator to compare to.
							 *
							 * @return The difference between the two iterators
							 * in chracter units (not characters or octets).
							*
							* @note
							* As some character sets are variable length, this method
							* must start from the begining of the string, and count
							* forward until the current spot is located. Then it must
							* backup one character (which may be multiple character width
							* values). Depending on the characters, it may have to
							* repeat this loop Sub times.
							*
							* @warning
							* For very long strings, this can be CPU intensive.
							 */
							int64_t	  operator-(self_type & Other);

							/**
							 * iterator: < compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return For forward iterators:
							 * - Returns true when the current character position
							 * is before the Rsh character position
							 * in the string.
							 *
							 *  For reverse iterators:
							 * - Returns true when the current character position
							 * is after the Rsh character position
							 * in the string.
							 */
							bool	  operator<(const self_type & Rhs);

							/**
							 * iterator: > compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return For forward iterators:
							 * - Returns true when the current character position
							 * is after the Rsh character position
							 * in the string.
							 *
							 *  For reverse iterators:
							 * - Returns true when the current character position
							 * is before the Rsh character position
							 * in the string.
							 */
							bool	  operator>(const self_type & Rhs);

							/**
							 * iterator: <= compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return For forward iterators:
							 * - Returns true when the current character position
							 * is before or the same as the Rsh character position
							 * in the string.
							 *
							 *  For reverse iterators:
							 * - Returns true when the current character position
							 * is after or the same as the Rsh character position
							 * in the string.
							 */
							bool	  operator<=(const self_type & Rhs);

							/**
							 * iterator: >= compare operator.
							 *
							 * @param Rhs the right hand side to compare (*this) to.
							 *
							 * @return For forward iterators:
							 * - Returns true when the current character position
							 * is after or the same as the Rsh character position
							 * in the string.
							 *
							 *  For reverse iterators:
							 * - Returns true when the current character position
							 * is before or same as the Rsh character position
							 * in the string.
							 */
							bool	  operator>=(const self_type & Rhs);

							/**
							 * iterator: inderection operator.
							 *
							 * @return the value of (this) iterator. Get the character.
							 */
							reference	  operator*() const;

							/**
							 * iterator: value of pointer.
							 *
							 * @return the value of the pointer to the current character.
							 */
							pointer	  operator->() const;

							/**
							 * iterator: value of pointer (to any (char*)value.
							 *
							 * @return the value of the pointer to the current character.
							 * Returns nullptr when Width() is not Is8Bit_t.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							const char		*  str8() const;

							/**
							 * iterator: value of pointer (to any (char16_t*)value.
							 *
							 * @return the value of the pointer to the current character.
							 * Returns nullptr when Width() is not Is16Bit_t.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							const char16_t		*  str16() const;

							/**
							 * iterator: value of pointer (to any (char32_t*)value.
							 *
							 * @return the value of the pointer to the current character.
							 * Returns nullptr when Width() is not Is32Bit_t.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							const char32_t		*  str32() const;

							/**
							 * iterator: value of pointer (to any (wchar_t*)value.
							 *
							 * @return the value of the pointer to the current character.
							 * Returns nullptr when Width() is not IsWBit_t.
							 *
							 * @note
							 * This may not be a NIL (0) terminated string.
							 * Use end<T>, and do not depend on a NIL.
							 */
							const wchar_t		*  strW() const;

							/**
							 * iterator: == compare operator.
							 *
							 * @param Rhs Compare (*this) to Rhs.
							 *
							 * @return true when (*this) is equal to Rhs.
							 */
							bool	  operator==(const self_type & Rhs) const;

							/**
							 * iterator: != compare operator.
							 *
							 * @param Rhs Compare (*this) to Rhs.
							 *
							 * @return true when (*this) is not equal to Rhs.
							 */
							bool	  operator!=(const self_type & Rhs) const;

							/**
							 * iterator: Random access dereference operator.
							 * Get the position for the desired character.
							 *
							 * @param Offset Which position to get.
							 * Values over end() will be truncated to end().
							 *
							 * @return An iterator at the named postion.
							 *
							 * @note
							 * Because of multibyte character sets UTF-8 and
							 * UTF-16, this method has to start at the beginning of the
							 * string and increment to the correct position.
							 *
							 * With UTF-32, it is a direct offset.
							 */
							self_type	  operator[](size_t Offset) const;


						private:

							friend class String;
							friend class ROString;
					};

					/**
					 * String: [] operator
					 *
					 * This method returns the nTh character (not the nTh octet
					 * and not the nTh character unit).
					 *
					 * This object returns a ROString (IsReadOnly() String),
					 * with the results. The ROString may have 1, 2, 3, or
					 * 4 CharacterUnitWidth_e objects in it, depending on the
					 * characer set used.
					 * This ROString must be deleted when no longer needed.
					 *
					 * @param nThCharacter Which character to get, (first is zero).
					 * The maximum nTh is (Length() - 1). Values over
					 * this amount, result in a nullptr being returned.
					 *
					 * @return The nTh character as a ROString. If nTh is larger
					 * then the size of the string, nullptr will be returned.
					 * The resulting ROString points into this object.
					 * @see Length().
					 */
					ROString	*	operator[](size_t nThCharacter) const;

					/**
					 * String.item: Get the value of nTh character unit.
					 *
					 * This method returns the nTh character unit (not character and
					 * and not the nTh octet).
					 *
					 * This object returns the character in 32-bits.
					 *
					 * @note
					 * operator[] may be a better choice.
					 *
					 * @param nThr Which character unit to get, (first is zero).
					 * The maximum nTh is (Length() - 1). Values over
					 * this amount, result in a nullptr being returned.
					 *
					 * @return The nTh character unit as a UTF-32 value.
					 */
					uint32_t	Item(uint64_t nThCharacter) const;

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing String to copy from.
					 *
					 * @return A copy of CopyFrom.
					 */
					String	&	operator =(const String & CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing String to copy from.
					 *
					 * @return A copy of CopyFrom.
					 */
					String	&	operator =(const ROString & CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing character to copy from.
					 * CopyFrom will be assumed to be in Current8BitCharset
					 * and Current8BitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(char CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing character to copy from.
					 * CopyFrom will be assumed to be in Current16BitCharset
					 * and Current16BitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(char16_t CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing character to copy from.
					 * CopyFrom will be assumed to be in Current32BitCharset
					 * and Current32BitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(char32_t CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing character to copy from.
					 * CopyFrom will be assumed to be in CurrentWBitCharset
					 * and CurrentWBitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(wchar_t CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing string to copy from.
					 * CopyFrom will be assumed to be in Current8BitCharset
					 * and Current8BitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(const char * const CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing string to copy from.
					 * CopyFrom will be assumed to be in Current16BitCharset
					 * and Current16BitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(const char16_t * const CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing string to copy from.
					 * CopyFrom will be assumed to be in Current32BitCharset
					 * and Current32BitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(const char32_t * const CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing string to copy from.
					 * CopyFrom will be assumed to be in CurrentWBitCharset
					 * and CurrentWBitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(const wchar_t * const CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing string to copy from.
					 * CopyFrom will be assumed to be in CurrentWBitCharset
					 * and CurrentWBitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(const std::string & CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing string to copy from.
					 * CopyFrom will be assumed to be in CurrentWBitCharset
					 * and CurrentWBitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(const std::u16string & CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing string to copy from.
					 * CopyFrom will be assumed to be in CurrentWBitCharset
					 * and CurrentWBitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(const std::u32string & CopyFrom);

					/**
					 * String: = Copy operator.
					 *
					 * @param CopyFrom The existing string to copy from.
					 * CopyFrom will be assumed to be in CurrentWBitCharset
					 * and CurrentWBitWidth.
					 *
					 * @return (*this) set to CopyFrom.
					 */
					String	&	operator =(const std::wstring & CopyFrom);

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other is nullptr.
					 * - Length() is zero and Other->Length() is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing String to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as  Other-Charset(),
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const String & other) const;

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other is nullptr.
					 * - Length() is zero and Other->Length() is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing String to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as  Other-Charset(),
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const ROString & other) const;

					/**
					 * String: == Compare string to character
					 * They are equal when:
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(char Other) const;

					/**
					 * String: == Compare string to character
					 * They are equal when:
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(char16_t Other) const;

					/**
					 * String: == Compare string to character
					 * They are equal when:
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(char32_t Other) const;

					/**
					 * String: == Compare string to character
					 * They are equal when:
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(wchar_t Other) const;

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other is nullptr.
					 * - Length() is zero and strlen(Other) is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const char * const Other) const;

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other is nullptr.
					 * - Length() is zero and strlen(Other) is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const char16_t * const Other) const;

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other is nullptr.
					 * - Length() is zero and strlen(Other) is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current32BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const char32_t * const Other) const;

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other is nullptr.
					 * - Length() is zero and strlen(Other) is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as CurrentWBitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const wchar_t * const Other) const;

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other.length() is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const std::string & Other) const;

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other.length() is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const std::u16string & Other) const;

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other.length() is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const std::u32string & Other) const;

					/**
					 * String: == Compare strings
					 * They are equal when:
					 * - Length() is zero and Other.length() is zero.
					 * - They have the same Length() and the contents of the
					 * strings are the same when compared in the same charset.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator ==(const std::wstring & Other) const;

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const String & Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const ROString & Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const char * const Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const char16_t * const Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const char32_t * const Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const wchar_t * const Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const std::string & Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const std::u16string  & Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const std::u32string & Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: != Compare strings
					 *
					 * @return (!(*this == Other));
					 */
					inline bool
					operator !=(const std::wstring & Other) const {
						return (!(*this == Other));
					}

					/**
					 * String: < compare strings
					 * (this) is less than Other when:
					 * - Other is nullptr and Length() > 0
					 * - Other is not nullptr and Length() < Other->Length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Other->Charset()
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator <(const String & Other) const;

					/**
					 * String: < compare strings
					 * (this) is less than Other when:
					 * - Other is nullptr and Length() > 0
					 * - Other is not nullptr and Length() < Other->Length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Other->Charset()
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator <(const ROString & Other) const;

					/**
					 * String: < Compare strings
					 * (this) is less than Other when:
					 * - Other is nullptr and Length() > 0
					 * - Other is not nullptr and Length() < strlen(Other).
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <(const char * const Other) const;

					/**
					 * String: < Compare strings
					 * (this) is less than Other when:
					 * - Other is nullptr and Length() > 0
					 * - Other is not nullptr and Length() < strlen(Other).
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <(const char16_t * const Other) const;

					/**
					 * String: < Compare strings
					 * (this) is less than Other when:
					 * - Other is nullptr and Length() > 0
					 * - Other is not nullptr and Length() < strlen(Other).
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current32BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <(const char32_t * const Other) const;

					/**
					 * String: < Compare strings
					 * (this) is less than Other when:
					 * - Other is nullptr and Length() > 0
					 * - Other is not nullptr and Length() < strlen(Other).
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as CurrentWBitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <(const wchar_t * const Other) const;

					/**
					 * String: < Compare strings
					 * (this) is less than Other when:
					 * - Length() < Other.length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <(const std::string & Other) const;

					/**
					 * String: < Compare strings
					 * (this) is less than Other when:
					 * - Length() < Other.length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <(const std::u16string & Other) const;

					/**
					 * String: < Compare strings
					 * (this) is less than Other when:
					 * - Length() < Other.length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current32BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <(const std::u32string & Other) const;

					/**
					 * String: < Compare strings
					 * (this) is less than Other when:
					 * - Length() < Other.length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as CurrentWBitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <(const std::wstring & Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - Other is not nullptr and (*this) == (*Other).
					 * - Other is not nullptr and Length() < Other->Length().
					 * - Other is not nullptr and Length() == Other->Length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Other->Charset()
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const String & Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - Other is not nullptr and (*this) == (*Other).
					 * - Other is not nullptr and Length() < Other->Length().
					 * - Other is not nullptr and Length() == Other->Length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Other->Charset()
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const ROString & Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - (*this == Other).
					 * - Other is not nullptr and Length() < strlen(Other).
					 * - Other is not nullptr and Length() == strlen(Other) and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const char * const Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - (*this == Other).
					 * - Other is not nullptr and Length() < strlen(Other).
					 * - Other is not nullptr and Length() == strlen(Other) and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const char16_t * const Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - (*this == Other).
					 * - Other is not nullptr and Length() < strlen(Other).
					 * - Other is not nullptr and Length() == strlen(Other) and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current32BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const char32_t * const Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - (*this == Other).
					 * - Other is not nullptr and Length() < strlen(Other).
					 * - Other is not nullptr and Length() == strlen(Other) and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as CurrentWBitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const wchar_t * const Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - (*this == Other).
					 * - Length() < Other.length().
					 * - Length() == Other.length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const std::string & Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - (*this == Other).
					 * - Length() < Other.length().
					 * - Length() == Other.length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const std::u16string & Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - (*this == Other).
					 * - Length() < Other.length().
					 * - Length() == Other.length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current32BitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const std::u32string & Other) const;

					/**
					 * String: <= Compare strings
					 * (this) is less than or equal to Other when:
					 * - (*this == Other).
					 * - Length() < Other.length().
					 * - Length() == Other.length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as CurrentWBitCharset,
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator <=(const std::wstring & Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Other is not nullptr and Length() > Other->Length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Other->Charset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const String & Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Other is not nullptr and Length() > Other->Length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Other->Charset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const ROString & Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Other is not nullptr and Length() > strlen(Other).
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const char * const Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Other is not nullptr and Length() > strlen(Other).
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const char16_t * const Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Other is not nullptr and Length() > strlen(Other).
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current32BitCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const char32_t * const Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Other is not nullptr and Length() > strlen(Other).
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as CurrentWBitCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const wchar_t * const Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Length() > Other.length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8BitCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const std::string & Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Length() > Other.length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16BitCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const std::u16string & Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Length() > Other.length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current32BitCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const std::u32string & Other) const;

					/**
					 * String: > Compare strings
					 * (this) is greater than Other when:
					 * - Length() > Other.length().
					 * - When an ordered string comparison from the results of
					 * strcoll() returns < 0 on these two strings.
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as CurrentWBitCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >(const std::wstring & Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - Other is not null and (*this) == (*Other).
					 * - Other is not nullptr and Length() > Other->Length().
					 * - Other is not nullptr and Length() == Other->Length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Other->Charset()
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace impact.
					 */
					bool		operator >=(const String & Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - Other is not null and (*this) == (*Other).
					 * - Other is not nullptr and Length() > Other->Length().
					 * - Other is not nullptr and Length() == Other->Length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Other->Charset()
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator >=(const ROString & Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - Other is not null and (*this == Other).
					 * - Other is not nullptr and Length() > strlen(Other).
					 * - Other is not nullptr and Length() == strlen(Other) and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8Charset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator >=(const char * const Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - Other is not null and (*this == Other).
					 * - Other is not nullptr and Length() > strlen(Other).
					 * - Other is not nullptr and Length() == strlen(Other) and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16Charset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator >=(const char16_t * const Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - Other is not null and (*this == Other).
					 * - Other is not nullptr and Length() > strlen(Other).
					 * - Other is not nullptr and Length() == strlen(Other) and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current32Charset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator >=(const char32_t * const Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - Other is not null and (*this == Other).
					 * - Other is not nullptr and Length() > strlen(Other).
					 * - Other is not nullptr and Length() == strlen(Other) and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as CurrentWCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator >=(const wchar_t * const Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - (*this == Other).
					 * - Length() > Other.length().
					 * - Other is not nullptr and Length() == Other.length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current8Charset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator >=(const std::string  & Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - (*this == Other).
					 * - Length() > Other.length().
					 * - Other is not nullptr and Length() == Other.length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current16Charset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator >=(const std::u16string & Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - (*this == Other).
					 * - Length() > Other.length().
					 * - Other is not nullptr and Length() == Other.length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as Current32Charset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator >=(const std::u32string & Other) const;

					/**
					 * String: >= Compare strings
					 * (this) is greater than or equal to Other when:
					 * - (*this == Other).
					 * - Length() > Other.length().
					 * - Other is not nullptr and Length() == Other.length() and
					 * an ordered string comparison from the results of strcoll()
					 * on these two strings returns <= 0).
					 *
					 * @param Other The existing string to compare to.
					 *
					 * @return true when they are both equal.
					 *
					 * @note
					 * When Charset() is not the same as CurrentWCharset
					 * then internally, a copy of the String with the lesser
					 * Length() will be made in the others charset, and those
					 * compared.
					 * Depending on the Length(), this may have a performace
					 * impact.
					 */
					bool		operator >=(const std::wstring & Other) const;

					/**
					 * String: + operator plus - Append string to the current
					 * object value, return a new object.
					 *
					 * @param Other The string to append from.
					 *
					 * @return A new String.
					 */
					String	&	operator +(const String & Other);

					/**
					 * String: + operator plus - Append string to the current
					 * object value, return a new object.
					 *
					 * @param Other The string to append from.
					 *
					 * @return A new String.
					 */
					String	&	operator +(const ROString & Other);

					/**
					 * String: + operator plus - Append string to the current
					 * object value, return a new object
					 *
					 * @param Other The string to append from.
					 * When nullptr, a new copy of the current string is provided.
					 *
					 * @return A new String.
					 */
					String	&	operator +(char Other);

					/**
					 * String: + operator plus - Append string to the current
					 * object value, return a new object
					 *
					 * @param Other The string to append from.
					 * When nullptr, a new copy of the current string is provided.
					 *
					 * @return A new String.
					 */
					String	&	operator +(char16_t Other);

					/**
					 * String: + operator plus - Append string to the current
					 * object value, return a new object
					 *
					 * @param Other The string to append from.
					 * When nullptr, a new copy of the current string is provided.
					 *
					 * @return A new String.
					 */
					String	&	operator +(char32_t Other);

					/**
					 * String: + operator plus - Append string to the current object
					 * value, return a new object
					 *
					 * @param Other The string to append from.
					 * When nullptr, a new copy of the current string is provided.
					 *
					 * @return A new String.
					 */
					String	&	operator +(wchar_t Other);

					/**
					 * String: + operator plus - Append string to the current object
					 * value, return a new object
					 *
					 * @param Other The string to append from.
					 * When nullptr, a new copy of the current string is provided.
					 *
					 * @return A new String.
					 */
					String	&	operator +(const char * const Other);

					/**
					 * String: + operator plus - Append string to the current
					 * object value, return a new object
					 *
					 * @param Other The string to append from.
					 * When nullptr, a new copy of the current string is provided.
					 *
					 * @return A new String.
					 */
					String	&	operator +(const char16_t * const Other);

					/**
					 * String: + operator plus - Append string to the current
					 * object value, return a new object
					 *
					 * @param Other The string to append from.
					 * When nullptr, a new copy of the current string is provided.
					 *
					 * @return A new String.
					 */
					String	&	operator +(const char32_t * const Other);

					/**
					 * String: + operator plus - Append string to the current
					 * object value, return a new object
					 *
					 * @param Other The string to append from.
					 * When nullptr, a new copy of the current string is provided.
					 *
					 * @return A new String.
					 */
					String	&	operator +(const wchar_t * const Other);

					/**
					 * String: + operator plus - Append string to the current
					 * object value, return a new object
					 *
					 * @param Other The string to append from.
					 *
					 * @return A new String.
					 */
					String	&	operator +(const std::string & Other);

					/**
					 * String: + operator plus - Append string to the current object
					 * value, return a new object
					 *
					 * @param Other The string to append from.
					 *
					 * @return A new String.
					 */
					String	&	operator +(const std::u16string & Other);

					/**
					 * String: + operator plus - Append string to the current object
					 * value, return a new object
					 *
					 * @param Other The string to append from.
					 *
					 * @return The new String.
					 */
					String	&	operator +(const std::u32string & Other);

					/**
					 * String: + operator plus - Append string to the current object
					 * value, return a new object
					 *
					 * @param Other The string to append from.
					 *
					 * @return The new String.
					 */
					String	&	operator +(const std::wstring & Other);

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(const String & Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(const ROString & Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 * When nullptr, nothing is done.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(char Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 * When nullptr, nothing is done.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(char16_t Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 * When nullptr, nothing is done.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(char32_t Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 * When nullptr, nothing is done.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(wchar_t Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 * When nullptr, nothing is done.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(const char * const Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 * When nullptr, nothing is done.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(const char16_t * const Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 * When nullptr, nothing is done.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(const char32_t * const Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 * When nullptr, nothing is done.
					 *
					 * @return The updated String.
					 */
					String	&
					operator +=(const wchar_t * const Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(const std::string & Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(const std::u16string & Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(const std::u32string & Other) {
						return (Append(Other));
					}

					/**
					 * String: += Append string to the current object.
					 *
					 * @param Other The existing String to append.
					 *
					 * @return The updated String.
					 */
					inline String	&
					operator +=(const std::wstring  & Other) {
						return (Append(Other));
					}

					/**
					 * String.lock() - Lock the string from usage - rarely needed
					 * in MT work.
					 *
					 * @return TRUE if you get the lock.
					 */
					bool		Lock() const;

					/**
					 * String.lock() - Lock the string from usage - rarely needed
					 * in MT work.
					 * Hangs until acquired.
					 *
					 * @return TRUE if you get the lock.
					 */
					bool		TryLock() const;

					/**
					 * String.lock() - Lock the string from usage - rarely needed
					 * in MT work.
					 * Returns with OUT hanging if already locked.
					 *
					 * @return TRUE if you unlock the lock.
					 */
					bool		Unlock() const;

					/**
					 * String.Get() - Get the value in multibyte format.
					 *
					 * @deprecated
					 * Use Get8()
					 *
					 * @see Get8()
					 */
					[[deprecated("Use Get8()")]]
					inline const char *
					Get() const {
						return (Get8());
					}

					/**
					 * String.Get8() - Get the value in multibyte format.
					 *
					 * @return The value in multibyte format, converts if needed
					 * from input charset.
					 * Returns a pointer to an internal structure that is updated
					 * on change of input.
					 * A StringCache pointer.
					 *
					 * @throws (Error*) when the input charset can not
					 * be converted to this objects output charset.
					 * The error number will be EILSEQ when invalid multibyte
					 * sequence has been encountered in the input.
					 * The error number will be EINVAL when an incomplete multibyte
					 * sequence has been encountered in the input.
					 *
					 * @note
					 * When the value of (this) object is updated, the results of a
					 * previous call to Get8() become undefnied. If you need the
					 * value from this call to persist across changes to (this) object,
					 * make a copy before altering (this) object.
					 */
					const char  *	Get8() const;

					/**
					 * String.Get16() - Get the value in (char16_t) format.
					 *
					 * @return The value in char16_t format, converts if needed
					 * from input charset.
					 * Returns a pointer to an internal structure that is updated
					 * on change of input.
					 * A StringCache pointer.
					 *
					 * @throws (Error*) when the input charset can not
					 * be converted to this objects output charset.
					 * The error number will be EILSEQ when invalid multibyte sequence
					 * has been encountered in the input.
					 * The error number will be EINVAL when an incomplete multibyte
					 * sequence has been encountered in the input.
					 *
					 * @note
					 * When the value of (this) object is updated, the results of a
					 * previous call to Get16() become undefnied. If you need the
					 * value from this call to persist across changes to (this) object,
					 * make a copy before altering (this) object.
					 */
					const char16_t  * 	Get16() const;

					/**
					 * String.Get32() - Get the value in (char32_t) format.
					 *
					 * @return The value in char32_t format, converts if needed
					 * from input charset.
					 * Returns a pointer to an internal structure that is updated
					 * on change of input.
					 * A StringCache pointer.
					 *
					 * @throws (Error*) when the input charset can not
					 * be converted to this objects output charset.
					 * The error number will be EILSEQ when invalid multibyte sequence
					 * has been encountered in the input.
					 * The error number will be EINVAL when an incomplete multibyte
					 * sequence has been encountered in the input.
					 *
					 * @note
					 * When the value of (this) object is updated, the results of a
					 * previous call to Get32() become undefnied. If you need the
					 * value from this call to persist across changes to (this) object,
					 * make a copy before altering (this) object.
					 */
					const char32_t * Get32() const;

					/**
					 * String.GetW() - Get the value in (wchar_t) format.
					 *
					 * @return The value in wchar_t format, converts if needed
					 * from input charset.
					 * Returns a pointer to an internal structure that is updated
					 * on change of input.
					 * A StringCache pointer.
					 *
					 * @throws (Error*) when the input charset can not
					 * be converted to this objects output charset.
					 * The error number will be EILSEQ when invalid multibyte sequence
					 * has been encountered in the input.
					 * The error number will be EINVAL when an incomplete multibyte
					 * sequence has been encountered in the input.
					 *
					 * @note
					 * When the value of (this) object is updated, the results of a
					 * previous call to GetW() become undefnied. If you need the
					 * value from this call to persist across changes to (this) object,
					 * make a copy before altering (this) object.
					 */
					const wchar_t	  *  	GetW() const;

					/**
					 * String.Length() - Get the string length.
					 *
					 * For example, in UTF-8, a single character could be 1, 2, 3,
					 * or 4 octets in length. This method will return (1).
					 *
					 * When the UTF-8 single character is:
					 * -One octet, CharacterLen() will return (1), Length()
					 * would return (1), and Octets8() will return (1).
					 * -Two octets, CharacterLen() will return (1), Length()
					 * would return (2), and Octets8() will return (2).
					 * -Three octets, CharacterLen() will return (1), Length()
					 * would return (3), and Octets8() will return (3).
					 * -Four octets, CharacterLen() will return (1), Length()
					 * would return (4), and Octets8() will return (4).
					 *
					 * When the UTF-16 single character is:
					 * -Two octets, CharacterLen() will return (1), Length()
					 * would return (1), and Octets8() will return (2).
					 * -Four octets, CharacterLen() will return (1), Length()
					 * would return (2), and Octets8() will return (4).
					 *
					 * When the UTF-32 single character is:
					 * -Four octets, CharacterLen() will return (1), Length()
					 * would return (1), and Octets8() will return (4).
					 *
					 * @return The number of character units in this String.
					 *
					 * @see CharacterLen() for the number of printable characters
					 * in the string.
					 *
					 * @see Octets8()
					 * to get the number of 8-bit octets in the Current8BitCharset.
					 *
					 * @see Octets16()
					 * to get the number of 8-bit octets in the Current16BitCharset.
					 *
					 * @see Octets32()
					 * to get the number of 8-bit octets in the
					 *
					 * @see OctetsW()
					 * to get the number of 8-bit octets in the CurrentWBitCharset.
					 */
					size_t			Length() const;

					/**
					 * Get the number of printable characters in the string.
					 * This returns the number of glyphs that this string represents.
					 *
					 * For example, in UTF-8, a single character could be 1, 2, 3,
					 * or 4 octets in length. This method will return (1).
					 *
					 * When the UTF-8 single character is:
					 * -One octet, CharacterLen() will return (1), Length()
					 * would return (1), and Octets8() will return (1).
					 * -Two octets, CharacterLen() will return (1), Length()
					 * would return (2), and Octets8() will return (2).
					 * -Three octets, CharacterLen() will return (1), Length()
					 * would return (3), and Octets8() will return (3).
					 * -Four octets, CharacterLen() will return (1), Length()
					 * would return (4), and Octets8() will return (4).
					 *
					 * When the UTF-16 single character is:
					 * -Two octets, CharacterLen() will return (1), Length()
					 * would return (1), and Octets8() will return (2).
					 * -Four octets, CharacterLen() will return (1), Length()
					 * would return (2), and Octets8() will return (4).
					 *
					 * When the UTF-32 single character is:
					 * -Four octets, CharacterLen() will return (1), Length()
					 * would return (1), and Octets8() will return (4).
					 *
					 * @return The number of pritable character units in this String.
					 *
					 * @see Length() for the number of character units in this String.
					 *
					 * @see Octets8()
					 * to get the number of 8-bit octets in the Current8BitCharset.
					 *
					 * @see Octets16()
					 * to get the number of 8-bit octets in the Current16BitCharset.
					 *
					 * @see Octets32()
					 * to get the number of 8-bit octets in the
					 *
					 * @see OctetsW()
					 * to get the number of 8-bit octets in the CurrentWBitCharset.
					 */
					size_t			CharacterLen() const;

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current8BitCharset.
					 *
					 * @param It The iterator position where the character
					 * is at.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current8BitCharset.
					 * With 8-bit character widths, this will be the number
					 * of octets the first characters consumes in Str.
					 */
					static size_t		CharacterUnits(const iterator & It);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current8BitCharset.
					 *
					 * @param It The iterator position where the character
					 * is at.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current8BitCharset.
					 * With 8-bit character widths, this will be the number
					 * of octets the first characters consumes in Str.
					 */
					static size_t		CharacterUnits(const const_iterator & It);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current8BitCharset.
					 *
					 * @param OneItem One character unit to be tested. May be
					 * the first of a longer sequence.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current8BitCharset.
					 * With 8-bit character widths, this will be the number
					 * of octets the first characters consumes in Str.
					 */
					static size_t		CharacterUnits(const char OneItem);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current8BitCharset.
					 *
					 * @param OneItem One character unit to be tested. May be
					 * the first of a longer sequence.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current8BitCharset.
					 * With 8-bit character widths, this will be the number
					 * of octets the first characters consumes in Str.
					 */
					static size_t		CharacterUnits(const char16_t OneItem);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current8BitCharset.
					 *
					 * @param OneItem One character unit to be tested. May be
					 * the first of a longer sequence.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current8BitCharset.
					 * With 8-bit character widths, this will be the number
					 * of octets the first characters consumes in Str.
					 */
					static size_t		CharacterUnits(const char32_t OneItem);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current8BitCharset.
					 *
					 * @param OneItem One character unit to be tested. May be
					 * the first of a longer sequence.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current8BitCharset.
					 * With 8-bit character widths, this will be the number
					 * of octets the first characters consumes in Str.
					 */
					static size_t		CharacterUnits(const wchar_t OneItem);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current8BitCharset.
					 *
					 * @param Str The first character (not octet) in the string
					 * will be tested.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current8BitCharset.
					 * With 8-bit character widths, this will be the number
					 * of octets the first characters consumes in Str.
					 */
					static size_t		CharacterUnits(const char * const Str);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current16BitCharset.
					 *
					 * @param Str The first character (not octet) in the string
					 * will be tested.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current16BitCharset.
					 * With 16-bit characters, each unit is two octets.
					 * This method returns the number of character units,
					 * typically 1 (2 octets) or 2 (4 octets).
					 */
					static size_t		CharacterUnits(const char16_t * const Str);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current32BitCharset.
					 *
					 * @param Str The first character (not octet) in the string
					 * will be tested.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current32BitCharset.
					 * With 32-bit characters, each unit is four octets.
					 * This method returns the number of character units,
					 * typically 1 (4 octets).
					 */
					static size_t		CharacterUnits(const char32_t * const Str);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current32BitCharset.
					 *
					 * @param Str The first character (not octet) in the string
					 * will be tested.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current32BitCharset.
					 * With 32-bit characters, each unit is four octets.
					 * This method returns the number of character units,
					 * typically 1 (4 octets).
					 */
					static size_t		CharacterUnits(const wchar_t * const Str);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current32BitCharset.
					 *
					 * @param Str The first character (not octet) in the string
					 * will be tested.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current32BitCharset.
					 * With wchar_t characters, each unit is two or four octets
					 * depending on the operating system.
					 *
					 * This method returns the number of character units.
					 * -For (sizeof(wchar_t) == 2), then 1 (2 octets) or 2 (4 octets)
					 * will be returned.
					 * -For (sizeof(wchar_t) == 4), then 1 (4 octets) will be returned.
					 * At the time of this implementation, it is beleived that no
					 * 32-bit character takes more than 4 octets (1 character unit).
					 */
					static size_t		CharacterUnits(const std::string & Str);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current32BitCharset.
					 *
					 * @param Str The first character (not octet) in the string
					 * will be tested.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current32BitCharset.
					 * With wchar_t characters, each unit is two or four octets
					 * depending on the operating system.
					 *
					 * This method returns the number of character units.
					 * -For (sizeof(wchar_t) == 2), then 1 (2 octets) or 2 (4 octets)
					 * will be returned.
					 * -For (sizeof(wchar_t) == 4), then 1 (4 octets) will be returned.
					 * At the time of this implementation, it is beleived that no
					 * 32-bit character takes more than 4 octets (1 character unit).
					 */
					static size_t		CharacterUnits(const std::u16string & Str);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current32BitCharset.
					 *
					 * @param Str The first character (not octet) in the string
					 * will be tested.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current32BitCharset.
					 * With wchar_t characters, each unit is two or four octets
					 * depending on the operating system.
					 *
					 * This method returns the number of character units.
					 * -For (sizeof(wchar_t) == 2), then 1 (2 octets) or 2 (4 octets)
					 * will be returned.
					 * -For (sizeof(wchar_t) == 4), then 1 (4 octets) will be returned.
					 * At the time of this implementation, it is beleived that no
					 * 32-bit character takes more than 4 octets (1 character unit).
					 */
					static size_t		CharacterUnits(const std::u32string & Str);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current32BitCharset.
					 *
					 * @param Str The first character (not octet) in the string
					 * will be tested.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current32BitCharset.
					 * With wchar_t characters, each unit is two or four octets
					 * depending on the operating system.
					 *
					 * This method returns the number of character units.
					 * -For (sizeof(wchar_t) == 2), then 1 (2 octets) or 2 (4 octets)
					 * will be returned.
					 * -For (sizeof(wchar_t) == 4), then 1 (4 octets) will be returned.
					 * At the time of this implementation, it is beleived that no
					 * 32-bit character takes more than 4 octets (1 character unit).
					 */
					static size_t		CharacterUnits(const std::wstring & Str);

					/**
					 * String.CharacterUnits() -
					 * Get the number of character unit widths for the
					 * first character in Str in the Current32BitCharset.
					 *
					 * @param Str The first character (not octet) in the string
					 * will be tested.
					 *
					 * @return The number of character unit widths for
					 * the first character in Str in the Current32BitCharset.
					 * With wchar_t characters, each unit is two or four octets
					 * depending on the operating system.
					 *
					 * This method returns the number of character units.
					 * -For (sizeof(wchar_t) == 2), then 1 (2 octets) or 2 (4 octets)
					 * will be returned.
					 * -For (sizeof(wchar_t) == 4), then 1 (4 octets) will be returned.
					 * At the time of this implementation, it is beleived that no
					 * 32-bit character takes more than 4 octets (1 character unit).
					 */
					static size_t		CharacterUnits(const String & Str);

					/**
					 * String.octets8() - Get the octet count of (char*) characters
					 * for this object.
					 *
					 * @return The octet count.
					 * This method will return the number of 8-bit values in
					 * this string.
					 */
					size_t			Octets8() const;

					/**
					 * String.octets16() - Get the octet count of (char16_t*) characters
					 * for this object.
					 *
					 * @return The octet count. An octet is an 8-bit value.
					 * This method will return the number of 8-bit values in
					 * this string.
					 */
					size_t			Octets16() const;

					/**
					 * String.octets32() - Get the octet count of (char32_t*) characters
					 * for this object.
					 *
					 * @return The octet count. An octet is an 8-bit value.
					 * This method will return the number of 8-bit values in
					 * this string.
					 */
					size_t			Octets32() const;

					/**
					 * String.octetsW() - Get the octet count of (wchar_t*) characters
					 * for this object.
					 *
					 * @return The octet count. An octet is an 8-bit value.
					 * This method will return the number of 8-bit values in
					 * this string.
					 */
					size_t			OctetsW() const;

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 * When nullptr, nothing is done.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const char * const NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 * When nullptr, nothing is done.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const char16_t * const NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 * When nullptr, nothing is done.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const char32_t * const NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 * When nullptr, nothing is done.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const wchar_t * const NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const std::string & NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const std::u16string & NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const std::u32string & NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const std::wstring & NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 * When nullptr, nothing is done.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const String & NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 * When nullptr, nothing is done.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 * When zero (0), all of NewStrData is appended.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const ROString & NewStrData,
					                   size_t CharCount = 0);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 * When nullptr, nothing is done.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const iterator & NewStrData,
					                   size_t CharCount);

					/**
					 * String.Append()
					 *
					 * Append newStrData up to charCount characters are
					 * appended.
					 *
					 * @param NewStrData The string to append.
					 * When nullptr, nothing is done.
					 *
					 * @param CharCount (Not octet count) The number of characters
					 * to append from NewStrData.
					 *
					 * @return this object updated.
					 */
					String	&	Append(const_iterator & NewStrData,
					                   size_t CharCount);

					/**
					 * String.Append()
					 *
					 * Append character as a single char.
					 *
					 * @param NewStrData The single character to append.
					 *
					 * @return this object updated.
					 */
					String	&	Append(char NewStrData);

					/**
					 * String.Append()
					 *
					 * Append character as a single char.
					 *
					 * @param NewStrData The single character to append.
					 *
					 * @return this object updated.
					 */
					String	&	Append(wchar_t NewStrData);

					/**
					 * String.Append()
					 *
					 * Append character as a single char.
					 *
					 * @param NewStrData The single character to append.
					 *
					 * @return this object updated.
					 */
					String	&	Append(char16_t NewStrData);

					/**
					 * String.Append()
					 *
					 * Append character as a single char.
					 *
					 * @param NewStrData The single character to append.
					 *
					 * @return this object updated.
					 */
					String	&	Append(char32_t NewStrData);

					/**
					 * String.Append()
					 *
					 * Append the numerical value of BinaryValue to this.
					 *
					 * @param NewStrData The value to append to this.
					 *
					 * @return this object updated.
					 */
					String	&	AppendValue(int8_t BinaryValue);

					/**
					 * String.Append()
					 *
					 * Append the numerical value of BinaryValue to this.
					 *
					 * @param NewStrData The value to append to this.
					 *
					 * @return this object updated.
					 */
					String	&	AppendValue(uint8_t BinaryValue);

					/**
					 * String.Append()
					 *
					 * Append the numerical value of BinaryValue to this.
					 *
					 * @param NewStrData The value to append to this.
					 *
					 * @return this object updated.
					 */
					String	&	AppendValue(int16_t binaryValue);

					/**
					 * String.Append()
					 *
					 * Append the numerical value of BinaryValue to this.
					 *
					 * @param NewStrData The value to append to this.
					 *
					 * @return this object updated.
					 */
					String	&	AppendValue(uint16_t  binaryValue);

					/**
					 * String.Append()
					 *
					 * Append the numerical value of BinaryValue to this.
					 *
					 * @param NewStrData The value to append to this.
					 *
					 * @return this object updated.
					 */
					String	&	AppendValue(int32_t binaryValue);

					/**
					 * String.Append()
					 *
					 * Append the numerical value of BinaryValue to this.
					 *
					 * @param NewStrData The value to append to this.
					 *
					 * @return this object updated.
					 */
					String	&	AppendValue(uint32_t binaryValue);

					/**
					 * String.Append()
					 *
					 * Append the numerical value of BinaryValue to this.
					 *
					 * @param NewStrData The value to append to this.
					 *
					 * @return this object updated.
					 */
					String	&	AppendValue(int64_t binaryValue);

					/**
					 * String.Append()
					 *
					 * Append the numerical value of BinaryValue to this.
					 *
					 * @param NewStrData The value to append to this.
					 *
					 * @return this object updated.
					 */
					String	&	AppendValue(uint64_t bianryValue);

					/**
					 * String.Append()
					 *
					 * Returns appended dt in ISO format
					 * 'YYYYMMDDTHHMMSS'
					 * 'YYYYMMDDTHHMMSSZ'.
					 * 'YYYYMMDDTHHMMSS+-hhmm'.
					 *
					 * @param dt The DateTime object pointer to append.
					 * Does nothiing when dt is nullptr.
					 *
					 * @return this object updated.
					 */
					String	&	AppendValue(const DateTime * const dt);

					/**
					 * String.Append()
					 *
					 * Returns appended dt in ISO format
					 * 'YYYYMMDDTHHMMSS'
					 * 'YYYYMMDDTHHMMSSZ'.
					 * 'YYYYMMDDTHHMMSS+-hhmm'.
					 *
					 * @param dt The DateTime object pointer to append.
					 *
					 * @return The this object updated.
					 */
					String	&	Append(const DateTime & dt);

					/**
					 * @deprecated Use Clear()
					 * @see Clear()
					 */
					[[deprecated("Use Clear()")]]
					inline void
					Empty() {
						Clear();
					}

					/**
					 * String.Clear()
					 *
					 * Remove all contents from the string.
					 * Does not clear the input and output character set
					 * names or widths. Just clears the string to empty.
					 */
					void			Clear();

					/**
					 * String.GetMem().
					 *
					 * A hook to a run time license.
					 */
					void		*	GetMem() const;

					/**
					 * String.sprintf()
					 *
					 * Like POSIX C sprintf, append the formatted string
					 * to this object.
					 *
					 * @param format The initial part of the formatted string
					 * and includes the format of the results appended.
					 *
					 * @return The number of characters in the string (strlen()).
					 */
					size_t		sprintf(const char * const format, ...);

					/**
					 * String.sprintf()
					 *
					 * Like POSIX C sprintf, append the formatted string
					 * to this object.
					 *
					 * @param format The initial part of the formatted string
					 * and includes the format of the results appended.
					 *
					 * @return The number of characters in the string (strlen()).
					 */
					size_t		sprintf(const wchar_t * const format, ...);

					/**
					 * String.sprintf()
					 *
					 * Like POSIX C sprintf, append the formatted string
					 * to this object.
					 *
					 * @param format The initial part of the formatted string
					 * and includes the format of the results appended.
					 *
					 * @return The number of characters in the string (strlen()).
					 */
					size_t		sprintf(const char16_t * const format, ...);

					/**
					 * String.sprintf()
					 *
					 * Like POSIX C sprintf, append the formatted string
					 * to this object.
					 *
					 * @param format The initial part of the formatted string
					 * and includes the format of the results appended.
					 *
					 * @return The number of characters in the string (strlen()).
					 */
					size_t		sprintf(const char32_t * const format, ...);

					/**
					 * String.sprintf()
					 *
					 * Like POSIX C sprintf, append the formatted string
					 * to this object.
					 *
					 * @param format The initial part of the formatted string
					 * and includes the format of the results appended.
					 *
					 * @return The number of characters in the string (strlen()).
					 */
					size_t		sprintf(const String & format, ...);

					/**
					 * String.sprintf()
					 *
					 * Like POSIX C sprintf, append the formatted string
					 * to this object.
					 *
					 * @param format The initial part of the formatted string
					 * and includes the format of the results appended.
					 *
					 * @return The number of characters in the string (strlen()).
					 */
					size_t		sprintf(const ROString & format, ...);

					/**
					 * String.ToLower()
					 *
					 * Convert this string to lower case in place.
					 */
					void		ToLower();

					/**
					 * String.ToLower()
					 *
					 * Static method.
					 *
					 * Create a new String from the (char*) converted to lower case.
					 *
					 * @param SomeString A string to covert to lower case.
					 *
					 * @return A new (String*) with SomeString converted to lower case.
					 */
					static String	*	ToLower(const char * const SomeString);

					/**
					 * String.ToLower()
					 *
					 * Static method.
					 *
					 * Create a new String from the (wchar_t*) converted to lower case.
					 *
					 * @param SomeString A string to covert to lower case.
					 *
					 * @return A new (String*) with SomeString converted to lower case.
					 */
					static String	*	ToLower(const wchar_t * const SomeString);

					/**
					 * String.ToLower()
					 *
					 * Static method.
					 *
					 * Create a new String from the (char16_t*) converted to lower
					 * case.
					 *
					 * @param SomeString A string to covert to lower case.
					 *
					 * @return A new (String*) with SomeString converted to lower case.
					 */
					static String	*	ToLower(const char16_t * const SomeString);

					/**
					 * String.ToLower()
					 *
					 * Static method.
					 *
					 * Create a new String from the (char32_t*) converted to lower
					 * case.
					 *
					 * @param SomeString A string to covert to lower case.
					 *
					 * @return A new (String*) with SomeString converted to lower case.
					 */
					static String	*	ToLower(const char32_t * const SomeString);

					/**
					 * String.ToLower()
					 *
					 * Static method.
					 *
					 * Create a new String from the (String*) converted to lower case.
					 *
					 * @param SomeString A string to covert to lower case.
					 *
					 * @return A new (String*) with SomeString converted to lower case.
					 */
					static String	*	ToLower(const String & SomeString);

					/**
					 * String.ToLower()
					 *
					 * Static method.
					 *
					 * Create a new String from the (String*) converted to lower case.
					 *
					 * @param SomeString A string to covert to lower case.
					 *
					 * @return A new (String*) with SomeString converted to lower case.
					 */
					static String	*	ToLower(const ROString & SomeString);

					/**
					 * String.ToUpper()
					 *
					 * Convert the string to UPPER case in place.
					 */
					void			ToUpper();

					/**
					 * String.ToUpper()
					 *
					 * Static method.
					 *
					 * Create a new String from the (char*) converted to UPPER case.
					 *
					 * @param SomeString A string to covert to UPPER case.
					 *
					 * @return A new (String*) with SomeString converted to UPPER case.
					 */
					static String	*	ToUpper(const char * const SomeString);

					/**
					 * String.ToUpper()
					 *
					 * Static method.
					 *
					 * Create a new String from the (wchar_t*) converted to UPPER case.
					 *
					 * @param SomeString A string to covert to UPPER case.
					 *
					 * @return A new (String*) with SomeString converted to UPPER case.
					 */
					static String	*	ToUpper(const wchar_t * const SomeString);

					/**
					 * String.ToUpper()
					 *
					 * Static method.
					 *
					 * Create a new String from the (char16_t*) converted to UPPER
					 * case.
					 *
					 * @param SomeString A string to covert to UPPER case.
					 *
					 * @return A new (String*) with SomeString converted to UPPER case.
					 */
					static String	*	ToUpper(const char16_t * const SomeString);

					/**
					 * String.ToUpper()
					 *
					 * Static method.
					 *
					 * Create a new String from the (char32_t*) converted to UPPER
					 * case.
					 *
					 * @param SomeString A string to covert to UPPER case.
					 *
					 * @return A new (String*) with SomeString converted to UPPER case.
					 */
					static String	*	ToUpper(const char32_t * const SomeString);

					/**
					 * String.ToUpper()
					 *
					 * Static method.
					 *
					 * Create a new String from the (String*) converted to UPPER case.
					 *
					 * @param SomeString A string to covert to UPPER case.
					 *
					 * @return A new (String*) with SomeString converted to UPPER case.
					 */
					static String	*	ToUpper(const String & SomeString);

					/**
					 * String.ToUpper()
					 *
					 * Static method.
					 *
					 * Create a new String from the (String*) converted to UPPER case.
					 *
					 * @param SomeString A string to covert to UPPER case.
					 *
					 * @return A new (String*) with SomeString converted to UPPER case.
					 */
					static String	*	ToUpper(const ROString & SomeString);

					/**
					 * String.Print()
					 *
					 * Print to FILE object.
					 * Just the string to FILE.
					 *
					 * @param Out The FILE object to print to.
					 */
					void			Print(FILE & Out) const;

					/**
					 * String.Print()
					 *
					 * Print to File object.
					 * Just the string to File.
					 *
					 * @param Out The File object to print to.
					 */
					void			Print(File & Out) const;

					/**
					 * String.Print()
					 *
					 * Print to FILE object.
					 * Just the string to FILE.
					 *
					 * @param Out The FILE object to print to.
					 */
					void			Print(std::ostream & Out) const;

					/**
					 * String.Write()
					 *
					 * Write this object to File.
					 * - Write a 1 octet value for (Is8Bit_t, Is16Bit_t, or Is32Bit_t).
					 * - Write the number of octets (not characters)
					 * in network byte order (uint64_t).
					 * - Write the octets.
					 *
					 * @return the number of octets written.
					 *
					 * @throw Error from File on File object error.
					 */
					uint64_t		Write(File & Fp);

					/**
					 * String.Read()
					 *
					 * Read this object from File.
					 * - Read a 1 octet value for (Is8Bit_t, Is16Bit_t, or Is32Bit_t).
					 * - Read the number of octets (not characters)x
					 * in network byte order (uint64_t).
					 * - Read the characters.
					 *
					 * @return the number of octets read.
					 *
					 * @throw Error from File on File object error.
					 */
					uint64_t		Read(File & Fp);

					/**
					 * String.xdr()
					 *
					 * Read/Write the string in XDR format.
					 *
					 * @param xdrs An initialized XDR object.
					 */
					virtual bool_t		xdr(XDR * xdrs);

					/**
					 * String.xdr_Strign()
					 *
					 * Read/Write the String in XDR format.
					 *
					 * @param xdrs An initialized XDR object.
					 *
					 * @param Pointer to the String object to be written.
					 */
					static bool_t		xdr_String(XDR * xdrs,
					                               String * Pointer);

					/**
					 * String.xdr_String()
					 *
					 * Read/Write the String in XDR format.
					 *
					 * @param xdrs An initialized XDR object.
					 *
					 * @param Pointer to the String object to be written.
					 */
					static int		xdr_String(XDR * xdrs,
					                           void * Pointer);

					/**
					 * String.ToCharset()
					 *
					 * Get this object in the named charset, into a new String.
					 *
					 * @param InCharset The name of the charset
					 * If this objects charset is the same as InCharset
					 * then a duplicate object is created.
					 *
					 * @param Width The width of the charset.
					 *
					 * @return A new object, in the named charset.
					 */
					String	*	ToCharset(const char * InCharset,
					                      CharacterUnitWidth_e Width) const;

					/**
					 * String.Charset8To8()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset8To8(const char * const FromCharset,
					            const char * const From,
					            const char * const ToCharset,
					            char *& To) {
						return (Charset8To8(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset8To8()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset, up to
					 * StrUnits character units.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset8To8(const char * const FromCharset,
					                        const char * const From,
					                        size_t FromUnits,
					                        const char * const ToCharset,
					                        char *& To);

					/**
					 * String.Charset8To16()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset8To16(const char * const FromCharset,
					             const char * const From,
					             const char * const ToCharset,
					             char16_t *& To) {
						return (Charset8To16(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset8To16()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset8To16(const char * const FromCharset,
					                         const char * const From,
					                         size_t FromUnits,
					                         const char * const ToCharset,
					                         char16_t *& To);

					/**
					 * String.Charset8To32()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset8To32(const char * const FromCharset,
					             const char * const From,
					             const char * const ToCharset,
					             char32_t *& To) {
						return (Charset8To32(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset8To32()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset8To32(const char * const FromCharset,
					                         const char * const From,
					                         size_t FromUnits,
					                         const char * const ToCharset,
					                         char32_t *& To);

					/**
					 * String.Charset8ToW()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset8ToW(const char * const FromCharset,
					            const char * const From,
					            const char * const ToCharset,
					            wchar_t *& To) {
						return (Charset8ToW(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset8ToW()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset8ToW(const char * const FromCharset,
					                        const char * const From,
					                        size_t FromUnits,
					                        const char * const ToCharset,
					                        wchar_t *& To);

					/**
					 * String.Charset16To8()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset16To8(const char * const FromCharset,
					             const char16_t * const From,
					             const char * const ToCharset,
					             char *& To) {
						return (Charset16To8(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset16To8()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset16To8(const char * const FromCharset,
					                         const char16_t * const From,
					                         size_t FromUnits,
					                         const char * const ToCharset,
					                         char *& To);

					/**
					 * String.Charset16To16()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset16To16(const char * const FromCharset,
					              const char16_t * const From,
					              const char * const ToCharset,
					              char16_t *& To) {
						return (Charset16To16(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset16To16()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset16To16(const char * const FromCharset,
					                          const char16_t * const From,
					                          size_t FromUnits,
					                          const char * const ToCharset,
					                          char16_t *& To);

					/**
					 * String.Charset16To32()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset16To32(const char * const FromCharset,
					              const char16_t * const From,
					              const char * const ToCharset,
					              char32_t *& To) {
						return (Charset16To32(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset16To32()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset16To32(const char * const FromCharset,
					                          const char16_t * const From,
					                          size_t FromUnits,
					                          const char * const ToCharset,
					                          char32_t *& To);

					/**
					 * String.Charset16ToW()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset16ToW(const char * const FromCharset,
					             const char16_t * const From,
					             const char * const ToCharset,
					             wchar_t *& To) {
						return (Charset16ToW(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset16ToW()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset16ToW(const char * const FromCharset,
					                         const char16_t * const From,
					                         size_t FromUnits,
					                         const char * const ToCharset,
					                         wchar_t *& To);

					/**
					 * String.Charset32To8()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset32To8(const char * const FromCharset,
					             const char32_t * const From,
					             const char * const ToCharset,
					             char *& To) {
						return (Charset32To8(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset32To8()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset32To8(const char * const FromCharset,
					                         const char32_t * const From,
					                         size_t FromUnits,
					                         const char * const ToCharset,
					                         char *& To);

					/**
					 * String.Charset32To16()
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 * Static method.
					 *
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset32To16(const char * const FromCharset,
					              const char32_t * const From,
					              const char * const ToCharset,
					              char16_t *& To) {
						return (Charset32To16(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset32To16()
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 * Static method.
					 *
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset32To16(const char * const FromCharset,
					                          const char32_t * const From,
					                          size_t FromUnits,
					                          const char * const ToCharset,
					                          char16_t *& To);

					/**
					 * String.Charset32To32()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset32To32(const char * const FromCharset,
					              const char32_t * const From,
					              const char * const ToCharset,
					              char32_t *& To) {
						return (Charset32To32(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset32To32()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset32To32(const char * const FromCharset,
					                          const char32_t * const From,
					                          size_t FromUnits,
					                          const char * const ToCharset,
					                          char32_t *& To);

					/**
					 * String.Charset32ToW()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					Charset32ToW(const char * const FromCharset,
					             const char32_t * const From,
					             const char * const ToCharset,
					             wchar_t *& To) {
						return (Charset32ToW(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.Charset32ToW()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	Charset32ToW(const char * const FromCharset,
					                         const char32_t * const From,
					                         size_t FromUnits,
					                         const char * const ToCharset,
					                         wchar_t *& To);

					/**
					 * String.CharsetWTo8()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					CharsetWTo8(const char * const FromCharset,
					            const wchar_t * const From,
					            const char * const ToCharset,
					            char *& To) {
						return (CharsetWTo8(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.CharsetWTo8()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	CharsetWTo8(const char * const FromCharset,
					                        const wchar_t * const From,
					                        size_t FromUnits,
					                        const char * const ToCharset,
					                        char *& To);

					/**
					 * String.CharsetWTo16()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					CharsetWTo16(const char * const FromCharset,
					             const wchar_t * const From,
					             const char * const ToCharset,
					             char16_t *& To) {
						return (CharsetWTo16(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.CharsetWTo16()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	CharsetWTo16(const char * const FromCharset,
					                         const wchar_t * const From,
					                         size_t FromUnits,
					                         const char * const ToCharset,
					                         char16_t *& To);

					/**
					 * String.CharsetWTo32()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					CharsetWTo32(const char * const FromCharset,
					             const wchar_t * const From,
					             const char * const ToCharset,
					             char32_t *& To) {
						return (CharsetWTo32(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.CharsetWTo32()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	CharsetWTo32(const char * const FromCharset,
					                         const wchar_t * const From,
					                         size_t FromUnits,
					                         const char * const ToCharset,
					                         char32_t *& To);

					/**
					 * String.CharsetWToW()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static inline bool
					CharsetWToW(const char * const FromCharset,
					            const wchar_t * const From,
					            const char * const ToCharset,
					            wchar_t *& To) {
						return (CharsetWToW(FromCharset, From, 0, ToCharset, To));
					}

					/**
					 * String.CharsetWToW()
					 *
					 * Static method.
					 *
					 * Convert From in FromCharset to To in ToCharset.
					 *
					 * @param FromCharset The charset that From is in.
					 * When nullptr, the default charset will be used.
					 *
					 * @param From The data to convert.
					 * When From is nullptr, nothing will be done and
					 * this method will return false.
					 *
					 * @param FromUnits Convert up to FromUnits character units
					 * from From string.
					 *
					 * @param ToCharset The charset to convert the data into.
					 * When nullptr, the default charset will be used.
					 *
					 * @param To The result will be stored here. This method
					 * will have allocated To when this method returns true.
					 *
					 * @return true if the conversion worked.
					 * This method uses the systems charset coversion methods.
					 * When the system does not support the conversion,
					 * this method will return false.
					 */
					static bool	CharsetWToW(const char * const FromCharset,
					                        const wchar_t * const From,
					                        size_t FromUnits,
					                        const char * const ToCharset,
					                        wchar_t *& To);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Str must be in the String::Current8Locale.
					 */
					static char	  *  strdup8(const char * const Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Str must be in the String::Current16Locale.
					 */
					static char	  *  strdup8(const char16_t * const Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char	  *  strdup8(const char32_t * const Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Str must be in the String::CurrentWLocale.
					 */
					static char	  *  strdup8(const wchar_t * const Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Str must be in the String::Current8Locale.
					 */
					static char	  *  strdup8(const std::string & Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Str must be in the String::Current16Locale.
					 */
					static char	  *  strdup8(const std::u16string & Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char	  *  strdup8(const std::u32string & Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Str must be in the String::CurrentWLocale.
					 */
					static char	  *  strdup8(const std::wstring & Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 */
					static char	  *  strdup8(const String & Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 */
					static char	  *  strdup8(const ROString & Str,
					                         size_t MaxLen = 0);

					/**
					 * String.strdup8()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param It The string location to copy from.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 * @note
					 * MaxLen set to zero is invalid when the string is a ROString
					 * or when the string is not terminated with a 0x00 octet.
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 */
					static char	  *  strdup8(const_iterator & It,
					                         size_t MaxLen);

					/**
					 * String.strdup16()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Str must be in the String::Current8Locale.
					 */
					static char16_t	  *  strdup16(const char * const Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current16Locale.
					 *
					 * @note Str must be in the String::Current16Locale.
					 */
					static char16_t	  *  strdup16(const char16_t * const Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char16_t	  *  strdup16(const char32_t * const Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Str must be in the String::CurrentWLocale.
					 */
					static char16_t	  *  strdup16(const wchar_t * const Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Str must be in the String::Current8Locale.
					 */
					static char16_t	  *  strdup16(const std::string & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Str must be in the String::Current16Locale.
					 */
					static char16_t	  *  strdup16(const std::u16string & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char16_t	  *  strdup16(const std::u32string & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char16_t	  *  strdup16(const std::wstring & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Copy a string (str).
					 * Static method.
					 *
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char16_t	  *  strdup16(const String & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Copy a string (str).
					 * Static method.
					 *
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char16_t	  *  strdup16(const ROString & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup16()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param It The string location to copy from.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 * @note
					 * MaxLen set to zero is invalid when the string is a ROString
					 * or when the string is not terminated with a 0x00 octet.
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 */
					static char16_t	  *  strdup16(const_iterator & It,
					                              size_t MaxLen);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current8Locale.
					 */
					static char32_t	  *  strdup32(const char * const Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current16Locale.
					 */
					static char32_t	  *  strdup32(const char16_t * const Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char32_t	  *  strdup32(const char32_t * const Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::CurrentWLocale.
					 */
					static char32_t	  *  strdup32(const wchar_t * const Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current8Locale.
					 */
					static char32_t	  *  strdup32(const std::string & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current16Locale.
					 */
					static char32_t	  *  strdup32(const std::u16string & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char32_t	  *  strdup32(const std::wstring & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char32_t	  *  strdup32(const std::u32string & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char32_t	  *  strdup32(const String & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static char32_t	  *  strdup32(const ROString & Str,
					                              size_t MaxLen = 0);

					/**
					 * String.strdup32()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param It The string location to copy from.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 * @note
					 * MaxLen set to zero is invalid when the string is a ROString
					 * or when the string is not terminated with a 0x00 octet.
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 */
					static char32_t	  *  strdup32(const_iterator & It,
					                              size_t MaxLen);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current8Locale.
					 */
					static wchar_t	  *  strdupW(const char * const Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current16Locale.
					 */
					static wchar_t	  *  strdupW(const char16_t * const Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static wchar_t	  *  strdupW(const char32_t * const Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::CurrentWLocale.
					 */
					static wchar_t	  *  strdupW(const wchar_t * const Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current8Locale.
					 */
					static wchar_t	  *  strdupW(const std::string & Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current16Locale.
					 */
					static wchar_t	  *  strdupW(const std::u16string & Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 * When MalLen is not zero, copy up to MaxLen characters.
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static wchar_t	  *  strdupW(const std::u32string & Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static wchar_t	  *  strdupW(const std::wstring & Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static wchar_t	  *  strdupW(const String & Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param Str The string to copy.
					 * When Str is nullptr, the results are nullptr.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return Str duplcicated with new memory allocated.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Str must be in the String::Current32Locale.
					 */
					static wchar_t	  *  strdupW(const ROString & Str,
					                             size_t MaxLen = 0);

					/**
					 * String.strdupW()
					 *
					 * Static method.
					 *
					 * Copy a string (str).
					 *
					 * @param It The string location to copy from.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 * @note
					 * MaxLen set to zero is invalid when the string is a ROString
					 * or when the string is not terminated with a 0x00 octet.
					 *
					 * @return Str duplcicated with new memory allocated.
					 * Returns nullptr when Str is nullptr.
					 * The results are in String::Current8Locale.
					 */
					static wchar_t	  *  strdupW(const_iterator & It,
					                             size_t MaxLen);

					/**
					 * String.strcat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param MaxLen When zero (0), copy the entire string.
					 * When MalLen is not zero, copy up to MaxLen characters.
					 * This will not terminate multibyte characters in the middle
					 * of the character. When non zero, this method copies
					 * up to MaxLen characters (not octets).
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char	  *  strcat8(char * ToString,
					                         const char * const FromStr);

					/**
					 * String.strcat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char	  *  strcat8(char * ToString,
					                         const char16_t * const FromStr);

					/**
					 * String.strcat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char	  *  strcat8(char * ToString,
					                         const char32_t * const FromStr);

					/**
					 * String.strcat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char	  *  strcat8(char * ToString,
					                         const wchar_t * const FromStr);

					/**
					 * String.strcat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char	  *  strcat8(char * ToString,
					                         const std::string & FromStr);

					/**
					 * String.strcat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char	  *  strcat8(char * ToString,
					                         const std::u16string & FromStr);

					/**
					 * String.strcat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char	  *  strcat8(char * ToString,
					                         const std::u32string & FromStr);

					/**
					 * String.strcat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char	  *  strcat8(char * ToString,
					                         const std::wstring & FromStr);

					/**
					 * String.strcat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 */
					static char	  *  strcat8(char * ToString,
					                         const String & FromStr);

					/**
					 * String.strcat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char16_t	  *  strcat16(char16_t * ToString,
					                              const char * const FromStr);

					/**
					 * String.strcat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char16_t	  *  strcat16(char16_t * ToString,
					                              const char16_t * const FromStr);

					/**
					 * String.strcat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char16_t	  *  strcat16(char16_t * ToString,
					                              const char32_t * const FromStr);


					/**
					 * String.strcat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char16_t	  *  strcat16(char16_t * ToString,
					                              const wchar_t * const FromStr);

					/**
					 * String.strcat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char16_t	  *  strcat16(char16_t * ToString,
					                              const std::string & FromStr);

					/**
					 * String.strcat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char16_t	  *  strcat16(char16_t * ToString,
					                              const std::u16string & FromStr);

					/**
					 * String.strcat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char16_t	  *  strcat16(char16_t * ToString,
					                              const std::u32string & FromStr);

					/**
					 * String.strcat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char16_t	  *  strcat16(char16_t * ToString,
					                              const std::wstring & FromStr);

					/**
					 * String.strcat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 */
					static char16_t	  *  strcat16(char16_t * ToString,
					                              const String & FromStr);

					/**
					 * String.strcat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char32_t	  *  strcat32(char32_t * ToString,
					                              const char * const FromStr);

					/**
					 * String.strcat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char32_t	  *  strcat32(char32_t * ToString,
					                              const char16_t * const FromStr);

					/**
					 * String.strcat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char32_t	  *  strcat32(char32_t * ToString,
					                              const char32_t * const FromStr);

					/**
					 * String.strcat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char32_t	  *  strcat32(char32_t * ToString,
					                              const wchar_t * const FromStr);

					/**
					 * String.strcat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char32_t	  *  strcat32(char32_t * ToString,
					                              const std::string & FromStr);

					/**
					 * String.strcat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char32_t	  *  strcat32(char32_t * ToString,
					                              const std::u16string & FromStr);

					/**
					 * String.strcat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char32_t	  *  strcat32(char32_t * ToString,
					                              const std::u32string & FromStr);

					/**
					 * String.strcat32()
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char32_t	  *  strcat32(char32_t * ToString,
					                              const std::wstring & FromStr);

					/**
					 * String.strcat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 */
					static char32_t	  *  strcat32(char32_t * ToString,
					                              const String & FromStr);

					/**
					 * String.strcatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static wchar_t	  *  strcatW(wchar_t * ToString,
					                             const char * const FromStr);

					/**
					 * String.strcatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static wchar_t	  *  strcatW(wchar_t * ToString,
					                             const char16_t * const FromStr);

					/**
					 * String.strcatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static wchar_t	  *  strcatW(wchar_t * ToString,
					                             const char32_t * const FromStr);

					/**
					 * String.strcatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static wchar_t	  *  strcatW(wchar_t * ToString,
					                             const wchar_t * const FromStr);

					/**
					 * String.strcatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static wchar_t	  *  strcatW(wchar_t * ToString,
					                             const std::string & FromStr);

					/**
					 * String.strcatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static wchar_t	  *  strcatW(wchar_t * ToString,
					                             const std::u16string & FromStr);

					/**
					 * String.strcatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static wchar_t	  *  strcatW(wchar_t * ToString,
					                             const std::u32string & FromStr);

					/**
					 * String.strcatW()
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static wchar_t	  *  strcatW(wchar_t * ToString,
					                             const std::wstring & FromStr);

					/**
					 * String.strcatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 */
					static wchar_t	  *  strcatW(wchar_t * ToString,
					                             const String & FromStr);

					/**
					 * String.strncat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char	  *  strncat8(char * ToString,
					                          const char * const FromStr,
					                          size_t Len);

					/**
					 * String.strncat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char	  *  strncat8(char * ToString,
					                          const char16_t * const FromStr,
					                          size_t Len);

					/**
					 * String.strncat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char	  *  strncat8(char * ToString,
					                          const char32_t * const FromStr,
					                          size_t Len);
					/**
					 * String.strncat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char	  *  strncat8(char * ToString,
					                          const wchar_t * const FromStr,
					                          size_t Len);

					/**
					 * String.strncat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char	  *  strncat8(char * ToString,
					                          const std::string & FromStr,
					                          size_t Len);

					/**
					 * String.strncat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char	  *  strncat8(char * ToString,
					                          const std::u16string & FromStr,
					                          size_t Len);

					/**
					 * String.strncat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char	  *  strncat8(char * ToString,
					                          const std::u32string & FromStr,
					                          size_t Len);

					/**
					 * String.strncat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char	  *  strncat8(char * ToString,
					                          const std::wstring & FromStr,
					                          size_t Len);

					/**
					 * String.strncat8()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of charactersx to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 */
					static char	  *  strncat8(char * ToString,
					                          const String & FromStr,
					                          size_t Len);

					/**
					 * String.strncat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of byte to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char16_t	  *  strncat16(char16_t * ToString,
					                               const char * const FromStr,
					                               size_t Len);

					/**
					 * String.strncat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char16_t	  *  strncat16(char16_t * ToString,
					                               const char16_t * const FromStr,
					                               size_t Len);

					/**
					 * String.strncat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char16_t	  *  strncat16(char16_t * ToString,
					                               const char32_t * const FromStr,
					                               size_t Len);
					/**
					 * String.strncat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char16_t	  *  strncat16(char16_t * ToString,
					                               const wchar_t * const FromStr,
					                               size_t Len);
					/**
					 * String.strncat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char16_t	  *  strncat16(char16_t * ToString,
					                               const std::string & FromStr,
					                               size_t Len);
					/**
					 * String.strncat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char16_t	  *  strncat16(char16_t * ToString,
					                               const std::u16string & FromStr,
					                               size_t Len);

					/**
					 * String.strncat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char16_t	  *  strncat16(char16_t * ToString,
					                               const std::u32string & FromStr,
					                               size_t Len);
					/**
					 * String.strncat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char16_t	  *  strncat16(char16_t * ToString,
					                               const std::wstring & FromStr,
					                               size_t Len);

					/**
					 * String.strncat16()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 */
					static char16_t	  *  strncat16(char16_t * ToString,
					                               const String & FromStr,
					                               size_t Len);

					/**
					 * String.strncat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char32_t	  *  strncat32(char32_t * ToString,
					                               const char * const FromStr,
					                               size_t Len);

					/**
					 * String.strncat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char32_t	  *  strncat32(char32_t * ToString,
					                               const char16_t * const FromStr,
					                               size_t Len);

					/**
					 * String.strncat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char32_t	  *  strncat32(char32_t * ToString,
					                               const char32_t * const FromStr,
					                               size_t Len);
					/**
					 * String.strncat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char32_t	  *  strncat32(char32_t * ToString,
					                               const wchar_t * const FromStr,
					                               size_t Len);

					/**
					 * String.strncat32()
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static char32_t	  *  strncat32(char32_t * ToString,
					                               const std::string & FromStr,
					                               size_t Len);
					/**
					 * String.strncat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static char32_t	  *  strncat32(char32_t * ToString,
					                               const std::u16string & FromStr,
					                               size_t Len);

					/**
					 * String.strncat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 */
					static char32_t	  *  strncat32(char32_t * ToString,
					                               const std::u32string & FromStr,
					                               size_t Len);

					/**
					 * String.strncat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static char32_t	  *  strncat32(char32_t * ToString,
					                               const std::wstring & FromStr,
					                               size_t Len);

					/**
					 * String.strncat32()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 */
					static char32_t	  *  strncat32(char32_t * ToString,
					                               const String & FromStr,
					                               size_t Len);
					/**
					 * String.strncatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static wchar_t	  *  strncatW(wchar_t * ToString,
					                              const char * const FromStr,
					                              size_t Len);

					/**
					 * String.strncatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static wchar_t	  *  strncatW(wchar_t * ToString,
					                              const char16_t * const FromStr,
					                              size_t Len);

					/**
					 * String.strncatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static wchar_t	  *  strncatW(wchar_t * ToString,
					                              const char32_t * const FromStr,
					                              size_t Len);
					/**
					 * String.strncatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static wchar_t	  *  strncatW(wchar_t * ToString,
					                              const wchar_t * const FromStr,
					                              size_t Len);

					/**
					 * String.strncatW()
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 */
					static wchar_t	  *  strncatW(wchar_t * ToString,
					                              const std::string & FromStr,
					                              size_t Len);
					/**
					 * String.strncatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 */
					static wchar_t	  *  strncatW(wchar_t * ToString,
					                              const std::u16string & FromStr,
					                              size_t Len);

					/**
					 * String.strncatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static wchar_t	  *  strncatW(wchar_t * ToString,
					                              const std::u32string & FromStr,
					                              size_t Len);

					/**
					 * String.strncatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 */
					static wchar_t	  *  strncatW(wchar_t * ToString,
					                              const std::wstring & FromStr,
					                              size_t Len);

					/**
					 * String.strncatW()
					 *
					 * Static method.
					 *
					 * Concatenate FromStr onto the end of ToString, and stop
					 * concatenating after Len characters, or until the end of FromStr
					 * is found.
					 *
					 * @param ToString Append to this string.
					 * When ToString is nullptr, nothing will be done
					 * and nullptr will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nohting is done.
					 *
					 * @return ToString with FromStr appended onto it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 */
					static wchar_t	  *  strncatW(wchar_t * ToString,
					                              const String & FromStr,
					                              size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 */
					static int	    strcmp(const char * const One,
					                       const char * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 */
					static int	    strcmp(const char * const One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set8Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strcmp(const char * const One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char * const One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char * const One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char * const One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const char * const One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set8Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strcmp(const char * const One,
					                       const std::wstring & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char * const One,
					                       const String & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char * const One,
					                       const ROString & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char * const One,
					                       iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char * const One,
					                       const_iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const char * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set8Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const std::wstring & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const String & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const ROString & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const wchar_t * const One,
					                       const_iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale
					 * and String::Current16Charset.
					 *
					 * @note
					 * Two must be in the String::Current8Locale
					 * and String::Current8Charset.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const char * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note4924

					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set16Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const std::wstring & Two);

					/**
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const String & Two);

					/**
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const ROString & Two);

					/**
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       iterator & Two);

					/**
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char16_t * const One,
					                       const_iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const char * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const std::wstring & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const String & Two);

					/**
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const ROString & Two);

					/**
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       iterator & Two);

					/**
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strcmp(const char32_t * const One,
					                       const_iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const char * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const std::wstring & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const String & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const ROString & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::string & One,
					                       const_iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const char * const Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const std::wstring & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const String & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const ROString & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u16string & One,
					                       const_iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const char * const Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const std::wstring & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const String & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const ROString & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::u32string & One,
					                       const_iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const char * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const std::wstring & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const String & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const ROString & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const std::wstring & One,
					                       const_iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const char * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const char * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const char16_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const wchar_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const std::string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const std::u16string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const std::u32string & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const std::wstring & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const std::wstring & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const String & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const String & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const ROString & Two);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const String & One,
					                       const_iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const ROString & Two);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       iterator & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const ROString & One,
					                       const_iterator & Two);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const char * const Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const char16_t * const Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const char32_t * const Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const wchar_t * const Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const std::string & Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const std::u16string & Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const std::u32string & Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const std::wstring & Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const String & Two);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const ROString & Two);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 */
					static int	    strcmp(const_iterator & One,
					                       const_iterator & Two);




					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 *zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of
					 * One and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const char * const One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0)
					 * is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const char * const One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char * const One,
					                        const char32_t * const Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char * const One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const char * const One,
					                        const std::string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const char * const One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char * const One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set8Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const char * const One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const char * const One,
					                        const String & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const char * const One,
					                        const ROString & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of
					 * One and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero
					 * if One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale
					 * and String::Current16Charset.
					 *
					 * @note
					 * Two must be in the String::Current16Locale
					 * and String::Current16Charset.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of
					 * One and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero
					 * if One (or the first n characters thereof) is found,
					 * respectively, to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const char32_t * const Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of
					 * One and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current8Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const wchar_t * const Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of
					 * One and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero
					 * if One (or the first n characters thereof) is found,
					 * respectively, to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const std::string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero
					 * if One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero
					 * if One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero
					 * if One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set16Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero
					 * if One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const String & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero
					 * if One (or the first n characters thereof) is found, respectively,
					 * to be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const char16_t * const One,
					                        const ROString & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One and
					 * Two. When Len is zero, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const char32_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const std::string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const String & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const char32_t * const One,
					                        const ROString & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One and
					 * Two. When Len is zero, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const char32_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const std::string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const String & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const wchar_t * const One,
					                        const ROString & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One and
					 * Two. When Len is zero, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const String & One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One and
					 * Two. When Len is zero, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const ROString & One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const String & One,
					                        const char16_t * const Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const ROString & One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const String & One,
					                        const char32_t * const Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const ROString & One,
					                        const char32_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const String & One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const ROString & One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const String & One,
					                        const std::string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const ROString & One,
					                        const std::string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const String & One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const ROString & One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const String & One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const ROString & One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const String & One,
					                        const std::wstring & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const ROString & One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const String & One,
					                        const String & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const ROString & One,
					                        const String & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const ROString & One,
					                        const ROString & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const String & One,
					                        const ROString & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One and
					 * Two. When Len is zero, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const char32_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const std::string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const std::u16string & Two,
					                        size_t Len);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const std::u32string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const String & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const ROString & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * One <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Two Compare to this string.
					 * Two <b>must be</b> a string terminated with a NIL (0).
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const_iterator & One,
					                        const_iterator & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One and
					 * Two. When Len is zero, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const std::string & One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const std::string & One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::string & One,
					                        const char32_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::string & One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const std::string & One,
					                        const std::string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const std::string & One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::string & One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const std::string & One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::string & One,
					                        const String & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::string & One,
					                        const ROString & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One and
					 * Two. When Len is zero, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const char32_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const std::string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const String & Two,
					                        size_t Len);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u16string & One,
					                        const ROString & Two,
					                        size_t Len);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One and
					 * Two. When Len is zero, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const char32_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const std::string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const String & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::u32string & One,
					                        const ROString & Two,
					                        size_t Len);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than
					 * zero if One is found, respectively, to be less than, to match,
					 * or be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One and
					 * Two. When Len is zero, nothing is done and zero (0) is returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const char * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or be
					 * greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to
					 * be less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const char16_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const char32_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 * When Two is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const wchar_t * const Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const std::string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const std::u16string & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const std::u32string & Two,
					                        size_t Len);
					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @note
					 * Two must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const std::wstring & Two,
					                        size_t Len);

					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const String & Two,
					                        size_t Len);


					/**
					 * Static method.
					 *
					 * Compare to strings, One and Two.
					 * Compare the two strings One and Two.
					 * It returns an integer less than, equal to, or greater than zero
					 * if One is found, respectively, to be less than, to match, or
					 * be greater than Two.
					 *
					 * @param One Compare to this string.
					 * When One is nullptr, nothing is done and zero (0) is returned.
					 *
					 * @param Two Compare Two to One.
					 *
					 * @param Len compare only the first (at most) Len characters of One
					 * and Two. When Len is zero, nothing is done and zero (0) is
					 * returned.
					 *
					 * @return An integer less than, equal to, or greater than zero if
					 * One (or the first n characters thereof) is found, respectively, to be
					 * less than, to match, or be greater than Two.
					 *
					 * @note
					 * One must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static int	    strncmp(const std::wstring & One,
					                        const ROString & Two,
					                        size_t Len);


					/**
					 * Static method.
					 *
					 * Get the number of character units in the string.
					 * This is not the number of octets and is not
					 * the number of characters.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @return The number of octets in FromStr.
					 *
					 * @see String::Set8Locale()
					 */
					static size_t	    strlen(const char * const FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of character units in the string.
					 * This is not the number of octets and is not
					 * the number of characters.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @return The number of octets in FromStr.
					 *
					 * @see String::Set16Locale()
					 */
					static size_t	    strlen(const char16_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of octets in the string.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @return The number of octets in FromStr.
					 *
					 * @see String::Set32Locale()
					 */
					static size_t	    strlen(const char32_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters units in the string.
					 * This is not the number of octets and not the number
					 * of characters (unless all of the characters
					 * are 1 character unit in length).
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @return The number of wchar_t units in FromStr.
					 *
					 * @see String::SetWLocale()
					 */
					static size_t	    strlen(const wchar_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters units in the string.
					 * This is not the number of octets and not the number
					 * of characters (unless all of the characters
					 * are 1 character unit in length).
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @return The number of wchar_t units in FromStr.
					 */
					static size_t	    strlen(const String & FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters units in the string.
					 * This is not the number of octets and not the number
					 * of characters (unless all of the characters
					 * are 1 character unit in length).
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @return The number of wchar_t units in FromStr.
					 */
					static size_t	    strlen(const ROString & FromStr);

					/**
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 * (char) character units are 1 octet in length each.
					 *
					 * @param FromIt The const_iterator to start checking at.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @return The number of characters in FromStr.
					 *
					 * @see String::Set8Locale()
					 */
					size_t	    CharacterLen(const_iterator & FromIt) const;

					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 * (char) character units are 1 octet in length each.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @return The number of characters in FromStr.
					 *
					 * @see String::Set8Locale()
					 */
					static size_t	    CharacterLen(const char * const FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 * (char16_t*) character units are 2 octet in length each.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @return The number of characters in FromStr.
					 *
					 * @see String::Set16Locale()
					 */
					static size_t	    CharacterLen(const char16_t * const
					                                 FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 * (char32_t) character units are 4 octet in length each.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @return The number of characters in FromStr.
					 *
					 * @see String::Set32Locale()
					 */
					static size_t	    CharacterLen(const char32_t * const
					                                 FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 * (wchar_t) character units are 2 octets in length
					 * on systems where (__SIZEOF_WCHAR__ == 2) and 4 octets in length
					 * on systems where (__SIZEOF_WCHAR__ == 4).
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @return The number of characters in FromStr.
					 *
					 * @see String::Set32Locale()
					 */
					static size_t	    CharacterLen(const wchar_t * const
					                                 FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 * (char) character units are 1 octet in length each.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @return The number of characters in FromStr.
					 *
					 * @see String::Set8Locale()
					 */
					static size_t	    CharacterLen(const std::string & FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 * (char16_t) character units are 2 octets in length each.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @return The number of characters in FromStr.
					 *
					 * @see String::Set16Locale()
					 */
					static size_t	    CharacterLen(const std::u16string &
					                                 FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 * (char32_t*) character units are 4 octets in length each.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @return The number of characters in FromStr.
					 *
					 * @see String::Set32Locale()
					 */
					static size_t	    CharacterLen(const std::u32string &
					                                 FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 * (wchar_t) character units are 2 octets in length
					 * on systems where (__SIZEOF_WCHAR__ == 2) and 4 octets in length
					 * on systems where (__SIZEOF_WCHAR__ == 4).
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @return The number of characters in FromStr.
					 *
					 * @see String::SetWLocale()
					 */
					static size_t	    CharacterLen(const std::wstring &
					                                 FromStr);

					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 *
					 * If CharacterWidth() returns Is8Bit_t, then:
					 * -(char) character units are 1 octet in length each.
					 *
					 * If CharacterWidth() returns Is16Bit_t, then:
					 * -(char16_t) character units are 2 octets in length each.
					 *
					 * If CharacterWidth() returns Is32Bit_t, then:
					 * -(char32_t) character units are 4 octets in length each.
					 *
					 * wchar_t characters are stored in char16_t or char32_t
					 * strings depending on the operaring systems wchar_t size.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @return The number of characters in FromStr.
					 */
					static size_t	    CharacterLen(const String & FromStr);
					/**
					 * Static method.
					 *
					 * Get the number of characters in the string.
					 * This is not the number of octets and not the number
					 * of characters units (unless all of the characters
					 * are 1 character unit in length).
					 *
					 * If CharacterWidth() returns Is8Bit_t, then:
					 * -(char) character units are 1 octet in length each.
					 *
					 * If CharacterWidth() returns Is16Bit_t, then:
					 * -(char16_t) character units are 2 octets in length each.
					 *
					 * If CharacterWidth() returns Is32Bit_t, then:
					 * -(char32_t) character units are 4 octets in length each.
					 *
					 * wchar_t characters are stored in char16_t or char32_t
					 * strings depending on the operaring systems wchar_t size.
					 *
					 * @param FromStr The string to test the length of.
					 * When FromStr is nullptr, nothing is done, and zero (0)
					 * is returned.
					 *
					 * @return The number of characters in FromStr.
					 */
					static size_t	    CharacterLen(const ROString & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static char	  *  strcpy8(char * ToString,
					                         const char * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set16Locale()
					 */
					static char	  *  strcpy8(char * ToString,
					                         const char16_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static char	  *  strcpy8(char * ToString,
					                         const char32_t * const FromStr);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static char	  *  strcpy8(char * ToString,
					                         const wchar_t * const FromStr);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static char	  *  strcpy8(char * ToString,
					                         const std::string & FromStr);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set16Locale()
					 */
					static char	  *  strcpy8(char * ToString,
					                         const std::u16string & FromString);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static char	  *  strcpy8(char * ToString,
					                         const std::u32string & FromString);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::Set8Locale()
					 * @see String::SetWLocale()
					 */
					static char	  *  strcpy8(char * ToString,
					                         const std::wstring & FromString);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::Set8Locale()
					 */
					static char	  *  strcpy8(char * ToString,
					                         const String & FromString);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr will
					 * be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set8Locale()
					 */
					static char16_t	  *  strcpy16(char16_t * ToString,
					                              const char * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static char16_t	  *  strcpy16(char16_t * ToString,
					                              const char16_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static char16_t	  *  strcpy16(char16_t * ToString,
					                              const char32_t * const FromStr);


					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static char16_t	  *  strcpy16(char16_t * ToString,
					                              const wchar_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set8Locale()
					 */
					static char16_t	  *  strcpy16(char16_t * ToString,
					                              const std::string & FromStr);


					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set16Locale()
					 */
					static char16_t	  *  strcpy16(char16_t * ToString,
					                              const std::u16string & FromStr);


					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static char16_t	  *  strcpy16(char16_t * ToString,
					                              const std::u32string & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::Set16Locale()
					 * @see String::SetWLocale()
					 */
					static char16_t	  *  strcpy16(char16_t * ToString,
					                              const std::wstring & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::Set16Locale()
					 */
					static char16_t	  *  strcpy16(char16_t * ToString,
					                              const String & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static char32_t	  *  strcpy32(char32_t * ToString,
					                              const char * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static char32_t	  *  strcpy32(char32_t * ToString,
					                              const char16_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static char32_t	  *  strcpy32(char32_t * ToString,
					                              const char32_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static char32_t	  *  strcpy32(char32_t * ToString,
					                              const wchar_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static char32_t	  *  strcpy32(char32_t * ToString,
					                              const std::string & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static char32_t	  *  strcpy32(char32_t * ToString,
					                              const std::u16string & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static char32_t	  *  strcpy32(char32_t * ToString,
					                              const std::u32string & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::SetWLocale()
					 */
					static char32_t	  *  strcpy32(char32_t * ToString,
					                              const std::wstring & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::Set32Locale()
					 */
					static char32_t	  *  strcpy32(char32_t * ToString,
					                              const String & FromStr);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::SetWLocale()
					 * @see String::Set8Locale()
					 */
					static wchar_t	  *  strcpyW(wchar_t * ToString,
					                             const char * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::CurrentWLocale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::SetWLocale()
					 * @see String::Set16Locale()
					 */
					static wchar_t	  *  strcpyW(wchar_t * ToString,
					                             const char16_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::CurrentWLocale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::SetWLocale()
					 */
					static wchar_t	  *  strcpyW(wchar_t * ToString,
					                             const char32_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::CurrentWLocale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::SetWLocale()
					 */
					static wchar_t	  *  strcpyW(wchar_t * ToString,
					                             const wchar_t * const FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::CurrentWLocale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static wchar_t	  *  strcpyW(wchar_t * ToString,
					                             const std::string & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::CurrentWLocale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static wchar_t	  *  strcpyW(wchar_t * ToString,
					                             const std::u16string & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::CurrentWLocale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::SetWLocale()
					 */
					static wchar_t	  *  strcpyW(wchar_t * ToString,
					                             const std::u32string & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::CurrentWLocale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::SetWLocale()
					 */
					static wchar_t	  *  strcpyW(wchar_t * ToString,
					                             const std::wstring & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::CurrentWLocale
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::SetWLocale()
					 */
					static wchar_t	  *  strcpyW(wchar_t * ToString,
					                             const String & FromStr);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will be
					 * coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static char	  *  strncpy8(char * ToString,
					                          const char * const FromStr,
					                          size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will be
					 * coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set16Locale()
					 */
					static char	  *  strncpy8(char * ToString,
					                          const char16_t * const FromStr,
					                          size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static char	  *  strncpy8(char * ToString,
					                          const char32_t * const FromStr,
					                          size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static char	  *  strncpy8(char * ToString,
					                          const wchar_t * const FromStr,
					                          size_t Len);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set8Locale()
					 */
					static char	  *  strncpy8(char * ToString,
					                          const std::string & FromStr,
					                          size_t Len);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set16Locale()
					 */
					static char	  *  strncpy8(char * ToString,
					                          const std::u16string & FromStr,
					                          size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set8Locale()
					 * @see String::Set32Locale()
					 */
					static char	  *  strncpy8(char * ToString,
					                          const std::u32string & FromStr,
					                          size_t Len);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::Set8Locale()
					 * @see String::SetWLocale()
					 */
					static char	  *  strncpy8(char * ToString,
					                          const std::wstring & FromStr,
					                          size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current8Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::Set8Locale()
					 */
					static char	  *  strncpy8(char * ToString,
					                          const String & FromStr,
					                          size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set8Locale()
					 */
					static char16_t	  *  strncpy16(char16_t * ToString,
					                               const char * const FromStr,
					                               size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr will
					 * be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static char16_t	  *  strncpy16(char16_t * ToString,
					                               const char16_t * const FromStr,
					                               size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static char16_t	  *  strncpy16(char16_t * ToString,
					                               const char32_t * const FromStr,
					                               size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static char16_t	  *  strncpy16(char16_t * ToString,
					                               const wchar_t * const FromStr,
					                               size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set8Locale()
					 */
					static char16_t	  *  strncpy16(char16_t * ToString,
					                               const std::string & FromStr,
					                               size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set16Locale()
					 */
					static char16_t	  *  strncpy16(char16_t * ToString,
					                               const std::u16string & FromStr,
					                               size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set16Locale()
					 * @see String::Set32Locale()
					 */
					static char16_t	  *  strncpy16(char16_t * ToString,
					                               const std::u32string & FromStr,
					                               size_t Len);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::Set16Locale()
					 * @see String::SetWLocale()
					 */
					static char16_t	  *  strncpy16(char16_t * ToString,
					                               const std::wstring & FromStr,
					                               size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current16Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::Set16Locale()
					 */
					static char16_t	  *  strncpy16(char16_t * ToString,
					                               const String & FromStr,
					                               size_t Len);


					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static char32_t	  *  strncpy32(char32_t * ToString,
					                               const char * const FromStr,
					                               size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static char32_t	  *  strncpy32(char32_t * ToString,
					                               const char16_t * const FromStr,
					                               size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static char32_t	*	strncpy32(char32_t * ToString,
					                              const char32_t * const FromStr,
					                              size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static char32_t	*	strncpy32(char32_t * ToString,
					                              const wchar_t * const FromStr,
					                              size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static char32_t	*	strncpy32(char32_t * ToString,
					                              const std::string & FromStr,
					                              size_t Len);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static char32_t	*	strncpy32(char32_t * ToString,
					                              const std::u16string & FromStr,
					                              size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static char32_t	*	strncpy32(char32_t * ToString,
					                              const std::u32string & FromStr,
					                              size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static char32_t	*	strncpy32(char32_t * ToString,
					                              const std::wstring & FromStr,
					                              size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::Set32Locale()
					 */
					static char32_t	*	strncpy32(char32_t * ToString,
					                              const String & FromStr,
					                              size_t Len);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::Set32Locale()
					 */
					static char32_t	*	strncpy32(char32_t * ToString,
					                              const ROString & FromStr,
					                              size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static wchar_t	  *  strncpyW(wchar_t * ToString,
					                              const char * const FromStr,
					                              size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static wchar_t	  *  strncpyW(wchar_t * ToString,
					                              const char16_t * const FromStr,
					                              size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static wchar_t	*	strncpyW(wchar_t * ToString,
					                             const char32_t * const FromStr,
					                             size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 * When FromStr is nullptr, nothing is done.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static wchar_t	*	strncpyW(wchar_t * ToString,
					                             const wchar_t * const FromStr,
					                             size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current8Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set8Locale()
					 */
					static wchar_t	*	strncpyW(wchar_t * ToString,
					                             const std::string & FromStr,
					                             size_t Len);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current16Locale.
					 *
					 * @see String::Set32Locale()
					 * @see String::Set16Locale()
					 */
					static wchar_t	*	strncpyW(wchar_t * ToString,
					                             const std::u16string & FromStr,
					                             size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::Current32Locale.
					 *
					 * @see String::Set32Locale()
					 */
					static wchar_t	*	strncpyW(wchar_t * ToString,
					                             const std::u32string & FromStr,
					                             size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @note
					 * FromStr must be in the String::CurrentWLocale.
					 *
					 * @see String::Set32Locale()
					 * @see String::SetWLocale()
					 */
					static wchar_t	*	strncpyW(wchar_t * ToString,
					                             const std::wstring & FromStr,
					                             size_t Len);

					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::Set32Locale()
					 */
					static wchar_t	*	strncpyW(wchar_t * ToString,
					                             const String & FromStr,
					                             size_t Len);
					/**
					 * Static method.
					 *
					 * Copy FromStr onto ToString. At most Len characters will
					 * be coped over.
					 *
					 * @param ToString Copy into this string.
					 * When ToString is nullptr, nothing will be done and nullptr
					 * will be returned.
					 *
					 * @param FromStr The string to copy.
					 *
					 * @param Len The number of characters to copy over.
					 * When Len is zero (0), nothing will be done.
					 *
					 * @return ToString with the contents of FromStr in it.
					 * The results are in String::Current32Locale.
					 *
					 * @note
					 * Their must be sufficent room in ToString, or
					 * or a memory overrun will occur.
					 *
					 * @see String::Set32Locale()
					 */
					static wchar_t	*	strncpyW(wchar_t * ToString,
					                             const ROString & FromStr,
					                             size_t Len);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const String & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param It The location in a String of where to start.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const_iterator & It,
					                            const String & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param It The location in a String of where to start.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const_iterator & It,
					                            const ROString & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const String & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const String & Reject);


					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const String & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const ROString & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const ROString & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const ROString & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const ROString & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const char * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const char * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const char * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param It The location in a String of where to start.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const_iterator & It,
					                            const char * Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const char * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const char16_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param It The location in a String of where to start.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const_iterator & It,
					                            const char16_t * Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const char16_t * const Reject,
					                            size_t RejectLen);


					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const char16_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const char16_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const char32_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const char32_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const char32_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param It The location in a String of where to start.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const_iterator & It,
					                            const char32_t * Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const char32_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const wchar_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param It The location in a String of where to start.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const_iterator & It,
					                            const wchar_t * Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const wchar_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const wchar_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const wchar_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const std::string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const std::string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const std::string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const std::string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const std::wstring & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const std::wstring & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const std::wstring & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const std::wstring & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const std::u16string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const std::u16string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const std::u16string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const std::u16string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            const std::u32string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const String & InStr,
					                            size_t InLen,
					                            const std::u32string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            const std::u32string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const ROString & InStr,
					                            size_t InLen,
					                            const std::u32string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const char * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const char * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const char16_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const char16_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const char32_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const char32_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const String & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const String & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const ROString & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const ROString & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const std::string & Reject);
					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const std::string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const std::u16string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const std::u16string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const std::u32string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const std::u32string & Reject,
					                            size_t RejectLen);


					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const wchar_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const wchar_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            const std::wstring & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char * const InStr,
					                            size_t InLen,
					                            const std::wstring & Reject,
					                            size_t RejectLen);


					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const char * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const char * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const char16_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const char16_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const char32_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const char32_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const wchar_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const wchar_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const String & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const String & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const ROString & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const ROString & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const std::string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const std::string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const std::u16string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const std::u16string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const std::u32string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const std::u32string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            const std::wstring & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char16_t * const InStr,
					                            size_t InLen,
					                            const std::wstring & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const char * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const char * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const char16_t * const Reject);
					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const char16_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const char32_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const char32_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const wchar_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const wchar_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const String & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const String & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const ROString & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const ROString & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const std::string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const std::string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const std::u16string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const std::u16string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const std::u32string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const std::u32string & Reject,
					                            size_t RejectLen);


					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            const std::wstring & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const char32_t * const InStr,
					                            size_t InLen,
					                            const std::wstring & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const char * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const char * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const char16_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const char16_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const char32_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const char32_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const wchar_t * const Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const wchar_t * const Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const String & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const String & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const ROString & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const ROString & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const std::string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const std::string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const std::u16string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const std::u16string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const std::u32string & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const std::u32string & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            const std::wstring & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param It The location in a String of where to start.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const_iterator & It,
					                            const std::wstring & Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t		strcspn(const wchar_t * const InStr,
					                            size_t InLen,
					                            const std::wstring & Reject,
					                            size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string object.
					 *
					 * @param ItStart The current iterative position. Where to start
					 * checking.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t	strcspn(const ROString & InStr,
					                        String::const_iterator & ItStart,
					                        const char * Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string object.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param ItStart The current iterative position. Where to start
					 * checking.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t	  strcspn(const ROString & InStr,
					                          size_t InLen,
					                          String::const_iterator & ItStart,
					                          const char * Reject,
					                          size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string object.
					 *
					 * @param ItStart The current iterative position. Where to start
					 * checking.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t	  strcspn(const ROString & InStr,
					                          String::const_iterator & ItStart,
					                          const char16_t * Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string object.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param ItStart The current iterative position. Where to start
					 * checking.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @param RejectLen The length of Reject to use.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t	  strcspn(const ROString & InStr,
					                          size_t InLen,
					                          String::const_iterator & ItStart,
					                          const char16_t * Reject,
					                          size_t RejectLen);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string object.
					 *
					 * @param ItStart The current iterative position. Where to start
					 * checking.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t	  strcspn(const ROString & InStr,
					                          String::const_iterator & ItStart,
					                          const char32_t * Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string object.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param ItStart The current iterative position. Where to start
					 * checking.
					 *
					 * @param RejectLen The length of Reject to use.
					 * checking.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t	  strcspn(const ROString & InStr,
					                          size_t InLen,
					                          String::const_iterator & ItStart,
					                          const char32_t * Reject,
					                          size_t RejectLent);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string object.
					 *
					 * @param ItStart The current iterative position. Where to start
					 * checking.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t	  strcspn(const ROString & InStr,
					                          String::const_iterator & ItStart,
					                          const wchar_t * Reject);

					/**
					 * Static method.
					 *
					 * The strcspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters not in Reject.
					 *
					 * Unlike ::strcspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Reject will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string object.
					 *
					 * @param InLen The length of InStr to check.
					 *
					 * @param ItStart The current iterative position. Where to start
					 *
					 * @param RejectLen The length of Reject to use.
					 * checking.
					 *
					 * @param Reject the list of unacceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters not in Reject.
					 */
					static size_t	  strcspn(const ROString & InStr,
					                          size_t InLen,
					                          String::const_iterator & ItStart,
					                          const wchar_t * Reject,
					                          size_t RejectLent);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const String & Accept);
					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const String & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const ROString & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const ROString & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const char * const Accept);
					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const char * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const char32_t * const Accept);
					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const wchar_t * const Accept);
					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const std::string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const std::string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const std::wstring & Accept);
					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const std::wstring & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const String & InStr,
					                           const std::u32string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const ROString & InStr,
					                           const std::u32string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char * const InStr,
					                           const char * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char * const InStr,
					                           const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char * const InStr,
					                           const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char * const InStr,
					                           const String & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char * const InStr,
					                           const std::string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char * const InStr,
					                           const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char * const InStr,
					                           const std::u32string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char * const InStr,
					                           const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char * const InStr,
					                           const std::wstring & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char16_t * const InStr,
					                           const char * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char16_t * const InStr,
					                           const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char16_t * const InStr,
					                           const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char16_t * const InStr,
					                           const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char16_t * const InStr,
					                           const String & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char16_t * const InStr,
					                           const std::string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char16_t * const InStr,
					                           const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char16_t * const InStr,
					                           const std::u32string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char16_t * const InStr,
					                           const std::wstring & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char32_t * const InStr,
					                           const char * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char32_t * const InStr,
					                           const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char32_t * const InStr,
					                           const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char32_t * const InStr,
					                           const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char32_t * const InStr,
					                           const String & Accept);


					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char32_t * const InStr,
					                           const std::string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char32_t * const InStr,
					                           const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char32_t * const InStr,
					                           const std::u32string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const char32_t * const InStr,
					                           const std::wstring & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const wchar_t * const InStr,
					                           const char * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const wchar_t * const InStr,
					                           const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const wchar_t * const InStr,
					                           const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const wchar_t * const InStr,
					                           const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const wchar_t * const InStr,
					                           const String & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const wchar_t * const InStr,
					                           const std::string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const wchar_t * const InStr,
					                           const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const wchar_t * const InStr,
					                           const std::u32string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const wchar_t * const InStr,
					                           const std::wstring & Accept);
					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const_iterator & InStr,
					                           const char * const Accept);


					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const_iterator & InStr,
					                           const char16_t * const Accept);


					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const_iterator & InStr,
					                           const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const_iterator & InStr,
					                           const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const_iterator & InStr,
					                           const String & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const_iterator & InStr,
					                           const std::string & Accept);


					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const_iterator & InStr,
					                           const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const_iterator & InStr,
					                           const std::u32string & Accept);


					/**
					 * Static method.
					 *
					 * The strspn() function calculates the length (in character
					 * units) of the initial segment of InStr which consists of
					 * characters in Accept.
					 *
					 * Unlike ::strspn(), this method works with multibyte
					 * UTF-8, UTF-16, and UTF-32 characters.
					 *
					 * Accept will be charset converted to be the same as InStr
					 * to perform the work.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return the length (in character units) of the initial segment
					 * of InStr which consist entirely of characters in Accept.
					 */
					static size_t		strspn(const_iterator & InStr,
					                           const std::wstring & Accept);

					/**
					 * Static method.
					 *
					 * Set the Current 8-bit Locale.
					 *
					 * @param TheLocale The new locale default.
					 */
					static void		Set8Locale(locale_t TheLocale);

					/**
					 * Static method.
					 *
					 * Get the Current 8-bit Locale.
					 *
					 * @return The Locale for 8-bits
					 */
					static locale_t		Get8Locale();

					/**
					 * Static method.
					 *
					 * Set the Current 16-bit Locale.
					 *
					 * @param TheLocale The new locale default.
					 */
					static void		Set16Locale(locale_t TheLocale);

					/**
					 * Static method.
					 *
					 * Get the Current 16-bit Locale.
					 *
					 * @return The Locale for 16-bits
					 */
					static locale_t		Get16Locale();

					/**
					 * Static method.
					 *
					 * Set the Current 32-bit Locale.
					 *
					 * @param TheLocale The new locale default.
					 */
					static void		Set32Locale(locale_t TheLocale);

					/**
					 * Static method.
					 *
					 * Get the Current 32-bit Locale.
					 *
					 * @return The Locale for 32-bits
					 */
					static locale_t		Get32Locale();

					/**
					 * @class TokSave String.hpp "<SaS/String/String.hpp>"
					 * With many object types supported, this object is used
					 * as the strtok() save state object.
					 */
					struct TokSave {
						/**
						 * StringTokSave - Default Constructor.
						 */
						inline
						TokSave() {
							Width = IsUnknownBit_t;
							SavePtr = nullptr;
							Charset = nullptr;
						};

						/**
						 * The character set of the original string.
						 * This is a copy, it is not freed.
						 * A StringCache pointer.
						 */
						const char	*	Charset;

						/**
						 * Width of original string.
						 */
						CharacterUnitWidth_e	Width;

						/**
						 * Used much like the ::strtok_r() type SavePtr.
						 */
						void	*	SavePtr;
					};

					/**
					 * Extract a substring from this String object.
					 * The substring will be a copy of the original
					 * data.
					 *
					 * Use this version of substring when you will need to
					 * copy or modify the resulting string data.
					 *
					 * When you will not be modifying or needing to copy
					 * the string data, call SubROString() and not SubString().
					 *
					 * @param Offset The first character from the new String
					 * object will start at Offset. (Offset is by character,
					 * not octet or character unit.)
					 *
					 * @param Count At most, get this many characters, up
					 * to the end of the string contents.
					 *
					 * When count is zero, then everything from Offset to the
					 * end of the string will be returned.
					 *
					 * Count is by character, not octet or character unit.
					 *
					 * @return A new String object, or nullptr when Offset
					 * is larger than the number of characters in this object.
					 */
					String		*	SubString(size_t Offset,
					                          size_t Count = 0) const;

					/**
					 * Extract a read-only substring from this String object.
					 * The result will be a pointer into this object data and
					 * will not be a copy.
					 *
					 * Use this version of substring when you do not need to
					 * copy or modify the resulting string data.
					 *
					 * When you do need to modify or copy the string data, call
					 * SubString() and not SubROString().
					 *
					 * @param Offset The first character from the new ROString
					 * object will start at Offset. (Offset is by character,
					 * not octet or character unit.)
					 *
					 * @param Count At most, get this many characters, up
					 * to the end of the string contents.
					 *
					 * When count is zero, then everything from Offset to the
					 * end of the string will be returned.
					 *
					 * Count is by character, not octet or character unit.
					 *
					 * @return A new ROString (a Read Only String) object, or nullptr
					 * when Offset is larger than the number of characters in this
					 * object.
					 */
					ROString	*	SubROString(size_t Offset,
					                            size_t Count = 0) const;

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const char * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const String & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const InStr,
					                           const ROString & Delim,
					                           TokSave & Save);


					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const char * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const String & Delim,
					                           TokSave & Save);
					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const InStr,
					                           const ROString & Delim,
					                           TokSave & Save);


					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const char * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const String & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const InStr,
					                           const ROString & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const char * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const String & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const InStr,
					                           const ROString & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const char * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const String & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string * InStr,
					                           const ROString & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string & InStr,
					                           const ROString & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const char * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const String & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string * InStr,
					                           const ROString & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const char * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const String & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string * InStr,
					                           const ROString & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const char * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const String & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring * InStr,
					                           const ROString & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String * InStr,
					                           const char * const Delim,
					                           TokSave & Save);
					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const char * const Delim,
					                           TokSave & Save);


					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String * InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const char16_t * const Delim,
					                           TokSave & Save);
					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String * InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String * InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String * InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String * InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String * InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String * InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String * InStr,
					                           const String & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const String & Delim,
					                           TokSave & Save);
					/**
					 * Static method.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok(), the
					 * string to be parsed should be specified in InStr. In each
					 * subsequent call that should parse the same string,
					 * call the String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls to strtok() that operate on the same string
					 * maintains a pointer that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param InStr The input string to test. Only supply this
					 * parameter on the first of a sequence of calls to tokenize the
					 * original string. InStr is never modified by this method.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString * InStr,
					                           const ROString & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char16_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const char32_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const wchar_t * const Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const String & Delim,
					                           TokSave & Save);
					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const ROString & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u16string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::u32string & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * This is the 2 argument version of strtok(). This is used
					 * subquent to calling th 3 argument version of strtok().
					 * This call continues to tokenize a string. This is the same as
					 * calling the 3 argument strtok() with the first argument
					 * nullptr cast to the orignal type.
					 *
					 * The strtok() function tokenizes a string into a sequence of zero
					 * or more tokens. On the first call to strtok() the 3 argument
					 * version is called, the string to be parsed should be specified
					 * in InStr. In each subsequent call that should parse the same
					 * string, you can call the 2 argument version of
					 * String::strtok(Delimiters, Save) method, which
					 * has the same effect as ::strtok((cast T*)nullptr, Delimiters,
					 * Save).
					 *
					 * The delim argument specifies a set of characters that delimit
					 * the tokens in the parsed string. The caller may specify
					 * different strings in delim in successive calls that parse the
					 * same string. Any one of the character in delim delimits the
					 * token.
					 *
					 * Each call to strtok() returns a pointer to a ROString
					 * containing the next token. This string does not include the
					 * delimiting character. If no more tokens are found, strtok()
					 * returns nullptr.
					 *
					 * A sequence of calls with the 3 argument strtok() followed by
					 * as many 2 argument strtok() calls as needed (until they
					 * return nullptr), operate on the same string that was maintained
					 * in Save that determines the point from which to
					 * start searching for the next token. The first call to strtok()
					 * sets this pointer to point to the first character of the string.
					 * The start of the next token is determined by scanning forward
					 * for the next non-delimiter character in the original InStr. If
					 * such a character is found, it is taken as the start of the next
					 * token. If no such character is found, then there are no more
					 * tokens, and strtok() returns nullptr. (A string that is empty
					 * or that contains only delimiters will thus cause strtok() to
					 * return nullptr on the first call.)
					 *
					 * The end of each token is found by scanning forward until either
					 * the next delimiter character is found or until the terminating
					 * NIL character ('\0') is encountered, or until at the end of
					 * the string when InStr is a IsReadOnly() String object.
					 *
					 * If a delimiter character is found, a new ROString is created
					 * as the return object that contains a pointer to the
					 * start of the new token, with a length value.
					 *
					 * Unlike ::strtok() or ::strtok_r(), this method never modifies
					 * the original string or string data.
					 *
					 * From the above description, it follows that a sequence of two or
					 * more contiguous delimiter characters in the parsed string is
					 * considered to be a single delimiter, and that delimiter
					 * character at the start or end of the string are ignored. Put
					 * another way: the tokens returned by strtok() are always
					 * nonempty strings. Thus, for example, given the string
					 * "aaa;;bbb,", successive calls to strtok() that specify the
					 * delimiter string ";," would return the strings "aaa" and "bbb",
					 * and then a null pointer.
					 *
					 * The Save argument is a pointer to a (void*) variable that is
					 * used internally by strtok() in order to maintain context between
					 * successive calls that parse the same string.
					 *
					 * Delim will be charset converted when needed, to be the same as
					 * InStr to perform the work. For faster processing, pass in
					 * Delim in the same charset as InStr, this will avoid having to
					 * convert it on every subsuquent call.
					 *
					 * @param Delim The delimiter string. A match to any single
					 * character. This does not look for a string match, just
					 * a character match.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return  A new (ROString*) object, or nullptr when
					 * no more tokens.
					 *
					 * @note
					 * - Caller must free the ROString results when no longer needed.
					 * - The ROString results points into InStr data, so if InStr is
					 * deleted, or modified, it will effect the results.
					 * - So, do not delete or modify InStr unil you copy
					 * any results you need to keep.
					 *
					 * @note
					 * A differences between ::strtok() and String::strtok():
					 * - There are 3 and 2 argument versions. The 2 argument
					 * version is the same as the 3 argument version, with InStr
					 * set to nullptr. This avoids having to cast nullptr to
					 * a correct type at compile time.
					 * - This method never modifies the original string.
					 */
					static ROString	*	strtok(const std::wstring & Delim,
					                           TokSave & Save);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not (char)objects).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char * const First,
					                            const char * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First is converted to the Current16BitCharset,
					 * then strncasecmp(char16_t*,char16_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not (char)objects).
					 *
					 * @return true if they are the same.
					 *
					 * @see Current16BitCharset
					 * @see Current16BitCharsetCurrent
					 */
					static int		strncasecmp(const char * const First,
					                            const char16_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First is converted to the Current32BitCharset,
					 * then strncasecmp(char32_t*,char32_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 *
					 * @see Current32BitCharset
					 * @see Current32BitCharsetCurrent
					 */
					static int		strncasecmp(const char * const First,
					                            const char32_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * - On systems where wchar_t is 16-bits:
					 * First is converted to the Current16BitCharset,
					 * then strncasecmp(char16_t*,char16_t*,size_t) will be called.
					 *
					 * - On systems where wchar_t is 32-bits:
					 * First is converted to the Current32BitCharset,
					 * then strncasecmp(char32_t*,char32_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char * const First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char * const First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First is converted to the Current16BitCharset,
					 * then strncasecmp(char16_t*,char16_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char * const First,
					                            const std::u16string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First is converted to the Current32BitCharset,
					 * then strncasecmp(char32_t*,char32_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char * const First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * - On systems where wchar_t is 16-bits:
					 * First is converted to the Current16BitCharset,
					 * then strncasecmp(char16_t*,char16_t*,size_t) will be called.
					 *
					 * - On systems where wchar_t is 32-bits:
					 * First is converted to the Current32BitCharset,
					 * then strncasecmp(char32_t*,char32_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char * const First,
					                            const std::wstring & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First is first converted to be  the same charset
					 * as Second.Charset(), then then the appropriate
					 * strncasecmp() will be called on the results.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char * const First,
					                            const String & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First is first converted to be  the same charset
					 * as Second.Charset(), then then the appropriate
					 * strncasecmp() will be called on the results.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char * const First,
					                            const ROString & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const char * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const char16_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const char32_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const std::wstring & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const std::u16string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const String & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const wchar_t * const First,
					                            const ROString & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const char * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const char16_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const char32_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters.
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const std::u16string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const std::wstring & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const String & Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char16_t * const First,
					                            const ROString & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const char * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const char16_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const char32_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const std::u16string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const std::wstring & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const String & Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const char32_t * const First,
					                            const ROString & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const String & First,
					                            const char * const Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const char * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const String & First,
					                            const char16_t * const Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const char16_t * const Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const String & First,
					                            const char32_t * const Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const char32_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const String & First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);


					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const String & First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const String & First,
					                            const std::u16string & Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const std::u16string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const String & First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const String & First,
					                            const std::wstring & Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const std::wstring & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const String & First,
					                            const String & Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const String & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const ROString & First,
					                            const ROString & Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const char * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const char * const Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const char * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const char16_t * const Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const char16_t * const Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const char16_t * const Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const char32_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const char32_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const char32_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const std::u16string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const std::u16string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const std::u16string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const std::wstring & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const std::wstring & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const std::wstring & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const String & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::string & First,
					                            const ROString & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const String & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u16string & First,
					                            const ROString & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const String & Second,
					                            size_t Len = 0);
					/**
					 * Static method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::u32string & First,
					                            const ROString & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const char * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const char16_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const char32_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const wchar_t * const Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const std::string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const std::u16string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const std::u32string & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const std::wstring & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const String & Second,
					                            size_t Len = 0);

					/**
					 * Static method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @param Len When Len > 0, compare up to this many characters
					 * (not octets).
					 *
					 * @return true if they are the same.
					 */
					static int		strncasecmp(const std::wstring & First,
					                            const ROString & Second,
					                            size_t Len = 0);

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char * const First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First is converted to the Current16BitCharset,
					 * then strcasecmp(char16_t*,char16_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 *
					 * @see Current16BitCharset
					 * @see Current16BitCharsetCurrent
					 */
					static inline int
					strcasecmp(const char * const First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First is converted to the Current32BitCharset,
					 * then strcasecmp(char32_t*,char32_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 *
					 * @see Current32BitCharset
					 * @see Current32BitCharsetCurrent
					 */
					static inline int
					strcasecmp(const char * const First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * - On systems where wchar_t is 16-bits:
					 * First is converted to the Current16BitCharset,
					 * then strcasecmp(char16_t*,char16_t*,size_t) will be called.
					 *
					 * - On systems where wchar_t is 32-bits:
					 * First is converted to the Current32BitCharset,
					 * then strcasecmp(char32_t*,char32_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char * const First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char * const First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First is converted to the Current16BitCharset,
					 * then strcasecmp(char16_t*,char16_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char * const First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First is converted to the Current32BitCharset,
					 * then strcasecmp(char32_t*,char32_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char * const First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * - On systems where wchar_t is 16-bits:
					 * First is converted to the Current16BitCharset,
					 * then strcasecmp(char16_t*,char16_t*,size_t) will be called.
					 *
					 * - On systems where wchar_t is 32-bits:
					 * First is converted to the Current32BitCharset,
					 * then strcasecmp(char32_t*,char32_t*,size_t) will be called.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char * const First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First is first converted to be  the same charset
					 * as Second.Charset(), then then the appropriate
					 * strcasecmp() will be called on the results.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char * const First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First is first converted to be  the same charset
					 * as Second.Charset(), then then the appropriate
					 * strcasecmp() will be called on the results.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char * const First,
					           const ROString & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const wchar_t * const First,
					           const ROString & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char16_t * const First,
					           const ROString & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const char32_t * const First,
					           const ROString & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const String & First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const ROString & First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const String & First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const ROString & First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const String & First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const ROString & First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const String & First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const ROString & First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const String & First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const ROString & First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const String & First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const ROString & First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const String & First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const ROString & First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const String & First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}


					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const ROString & First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const String & First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}
					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const ROString & First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::string & First,
					           const ROString & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u16string & First,
					           const ROString & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}
					/**
					 * Static inline method.
					 *
					 * Compare character strings.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::u32string & First,
					           const ROString & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const char * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const char16_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const char32_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const wchar_t * const Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const std::string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const std::u16string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const std::u32string & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const std::wstring & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const String & Second) {
						return (strncasecmp(First, Second, 0));
					}
					/**
					 * Static inline method.
					 *
					 * Compare character strings, ignoring case.
					 * First or Second will be converted to be in the same
					 * charsets, then compared.
					 *
					 * @param First Compare this string.
					 *
					 * @param Second to this string.
					 *
					 * @return true if they are the same.
					 */
					static inline int
					strcasecmp(const std::wstring & First,
					           const ROString & Second) {
						return (strncasecmp(First, Second, 0));
					}

					/**
					 * Return a pointer to the first occurence of the character
					 * CharToFind in this string.
					 *
					 * @param CharToFind  The character to look for. A pointer
					 * to the possibly multibyte character to find.
					 *
					 * @return The iterator to the found character. Or end()
					 * when none found.
					 *
					 * Returns end() when InputWidth() does not return Is8Bit_t.
					 */
					const_iterator	 & 	strchr(const char * const CharToFind)
					const;

					/**
					 * Return a pointer to the first occurence of the character
					 * CharToFind in this string.
					 *
					 * @param CharToFind  The character to look for. A pointer
					 * to the possibly multibyte character to find.
					 *
					 * @return The iterator to the found character. Or end()
					 * when none found.
					 *
					 * Returns end() when InputWidth() does not return Is16Bit_t.
					 */
					const_iterator	 & 	strchr(const char16_t * const CharToFind)
					const;

					/**
					 * Return a pointer to the first occurence of the character
					 * CharToFind in this string.
					 *
					 * @param CharToFind  The character to look for. A pointer
					 * to the possibly multibyte character to find.
					 *
					 * @return The iterator to the found character. Or end()
					 * when none found.
					 *
					 * Returns end() when InputWidth() does not return Is32Bit_t.
					 */
					const_iterator	 & 	strchr(const char32_t * const CharToFind)
					const;

					/**
					 * Return a pointer to the first occurence of the character
					 * CharToFind in this string.
					 *
					 * @param CharToFind  The character to look for. A pointer
					 * to the possibly multibyte character to find.
					 *
					 * @return The iterator to the found character. Or end()
					 * when none found.
					 *
					 * Returns end() when InputWidth() does not return IsWBit_t.
					 */
					const_iterator	 & 	strchr(const wchar_t * const CharToFind)
					const;

					/**
					 * Static static method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char	*	strchr(const char * const InStr,
					                       char CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char	*	strchr(const char * const InStr,
					                       const char * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO u'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char	*	strchr(const char * const InStr,
					                       char16_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char	*	strchr(const char * const InStr,
					                       const char16_t * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO U'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char	*	strchr(const char * const InStr,
					                       char32_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char	*	strchr(const char * const InStr,
					                       const char32_t * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO L'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char	*	strchr(const char * const InStr,
					                       wchar_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char	*	strchr(const char * const InStr,
					                       const wchar_t * const CharToFind);
					/**
					 * Static static method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static const_iterator	&	strchr(const_iterator & InStr,
					                                   char CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static const_iterator	&	strchr(const_iterator & InStr,
					                                   const char * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO u'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static const_iterator	&	strchr(const_iterator & InStr,
					                                   char16_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static const_iterator	&	strchr(const_iterator & InStr,
					                                   const char16_t * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO U'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static const_iterator	&	strchr(const_iterator & InStr,
					                                   char32_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static const_iterator	&	strchr(const_iterator & InStr,
					                                   const char32_t * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO L'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static const_iterator	&	strchr(const_iterator & InStr,
					                                   wchar_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static const_iterator	&	strchr(const_iterator & InStr,
					                                   const wchar_t * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char16_t	*	strchr(const char16_t * const InStr,
					                           char CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char16_t	*	strchr(const char16_t * const InStr,
					                           const char * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO u'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char16_t	*	strchr(const char16_t * const InStr,
					                           char16_t CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char16_t	*	strchr(const char16_t * const InStr,
					                           const char16_t * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO U'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char16_t	*	strchr(const char16_t * const InStr,
					                           char32_t CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char16_t	*	strchr(const char16_t * const InStr,
					                           const char32_t * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO L'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char16_t	*	strchr(const char16_t * const InStr,
					                           wchar_t CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the first character
					 * in CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for, the multibyte
					 * character to find.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char16_t	*	strchr(const char16_t * const InStr,
					                           const wchar_t * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char32_t	*	strchr(const char32_t * const InStr,
					                           char CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char32_t	*	strchr(const char32_t * const InStr,
					                           const char * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO u'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char32_t	*	strchr(const char32_t * const InStr,
					                           char16_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO u'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char32_t	*	strchr(const char32_t * const InStr,
					                           const char16_t * const CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO U'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char32_t	*	strchr(const char32_t * const InStr,
					                           char32_t CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO U'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char32_t	*	strchr(const char32_t * const InStr,
					                           const char32_t * const CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO L'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char32_t	*	strchr(const char32_t * const InStr,
					                           wchar_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO L'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static char32_t	*	strchr(const char32_t * const InStr,
					                           const wchar_t * const CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static wchar_t	*	strchr(const wchar_t * const InStr,
					                           char CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO '\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static wchar_t	*	strchr(const wchar_t * const InStr,
					                           const char * const CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO u'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static wchar_t	*	strchr(const wchar_t * const InStr,
					                           char16_t CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO u'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static wchar_t	*	strchr(const wchar_t * const InStr,
					                           const char16_t * const CharToFind);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO U'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static wchar_t	*	strchr(const wchar_t * const InStr,
					                           char32_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO U'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static wchar_t	*	strchr(const wchar_t * const InStr,
					                           const char32_t * const CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO L'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static wchar_t	*	strchr(const wchar_t * const InStr,
					                           wchar_t CharToFind);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Return a pointer to the first occurence of the character
					 * CharToFind in the string InStr.
					 *
					 * @param InStr The string to search.
					 *
					 * @param CharToFind  The character to look for.
					 *
					 * @return A pointer to the first occurence of the
					 * character CharToFind, or nullptr when not found.
					 * When CharToFind is a ZERO L'\0', then the returned value will
					 * point to the terminating zero.
					 *
					 * When InStr is nullptr, strchr() will return nullptr.
					 */
					static wchar_t	*	strchr(const wchar_t * const InStr,
					                           const wchar_t * const CharToFind);

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<char> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not Is8Bit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const char * const Accept) const;

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<char16_t> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not Is16Bit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const char16_t * const Accept)
					const;

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<char32_t> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not Is32Bit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const char32_t * const Accept)
					const;

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<wchar_t> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not IsWBit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const wchar_t * const Accept)
					const;

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<wchar_t> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not IsWBit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const std::string & Accept)
					const;

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<wchar_t> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not IsWBit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const std::u16string & Accept)
					const;

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<wchar_t> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not IsWBit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const std::u32string & Accept)
					const;

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<wchar_t> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not IsWBit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const std::wstring & Accept)
					const;

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<wchar_t> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not IsWBit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const String & Accept) const;

					/**
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return A const_iterator<wchar_t> to the first occurrence of
					 * any character in Accept, that is in InStr, or end() when none.
					 *
					 * When InputWidth() is not IsWBit_t, this method returns end().
					 */
					const_iterator	 & 	strpbrk(const ROString & Accept) const;

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const char * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const String & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const ROString & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const std::string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const std::u32string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char	* strpbrk(const char * const InStr,
					                              const std::wstring & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const char * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const String & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const ROString & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const std::string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const std::u32string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char16_t	* strpbrk(const char16_t * const
					                                  InStr,
					                                  const std::wstring & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const char * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const String & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const ROString & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const std::string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const std::u32string & Accept);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const char32_t	* strpbrk(const char32_t * const
					                                  InStr,
					                                  const std::wstring & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const char * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const char16_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const char32_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const wchar_t * const Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const String & Accept);
					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const ROString & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const std::string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const std::u16string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const std::u32string & Accept);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * The strpbrk() function locates the first occurrence in the
					 * string InStr from the Accept string.
					 *
					 * @param InStr The input string.
					 *
					 * @param Accept the list of acceptable characters.
					 *
					 * @return a pointer to the first occurrence  of any character
					 * in Accept, that is in InStr, or nullptr when none.
					 */
					static const wchar_t	* strpbrk(const wchar_t * const InStr,
					                                  const std::wstring & Accept);

					/**
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A const_iterator<char> to the first occurance
					 * of LookFor in this.
					 * Returns end() when none found or CharacterWidth() != Is8Bit_t.
					 */
					const_iterator	 & 	strstr(const char * const LookFor) const;

					/**
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A const_iterator<char16_t> to the first occurance
					 * of LookFor in this.
					 * Returns end() when none found or CharacterWidth() != Is8Bit_t.
					 */
					const_iterator	 & 	strstr(const char16_t * const LookFor)
					const;

					/**
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A const_iterator<char32_t> to the first occurance
					 * of LookFor in this.
					 * Returns end() when none found or CharacterWidth() != Is32Bit_t.
					 */
					const_iterator	 & 	strstr(const char32_t * const LookFor)
					const;

					/**
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A const_iterator<wchar_t> to the first occurance
					 * of LookFor in this.
					 * Returns end() when none found or CharacterWidth() != IsWBit_t.
					 */
					const_iterator	 & 	strstr(const wchar_t * const LookFor)
					const;

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const char * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const char16_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when no found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const char32_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const wchar_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const std::string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const std::u16string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const std::u32string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const std::wstring & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const String & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char	* strstr(const char * const
					                             ToSearchString,
					                             const ROString & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const char * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const char16_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const char32_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const wchar_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const std::string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const std::u16string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const std::u32string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const std::wstring & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const String & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char16_t	* strstr(const char16_t * const
					                                 ToSearchString,
					                                 const ROString & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const char * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const char16_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const char32_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const wchar_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const std::string & LookFor);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const std::u16string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const std::u32string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const std::wstring & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const String & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const char32_t	* strstr(const char32_t * const
					                                 ToSearchString,
					                                 const ROString & LookFor);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const char * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const char16_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const char32_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const wchar_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const std::string & LookFor);


					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const std::u16string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const std::u32string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const std::wstring & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const String & LookFor);
					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param ToSearchString The string to search.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const wchar_t	* strstr(const wchar_t * const
					                                 ToSearchString,
					                                 const ROString & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	 strstr(const_iterator & StartIt,
					                                const char * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const char16_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const char32_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const wchar_t * const LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const std::string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const std::u16string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const std::u32string & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const std::wstring & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const String & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const ROString & LookFor);

					/**
					 * Static method.
					 *
					 * Multibyte method.
					 *
					 * Look for a string within a string.
					 *
					 * @param StartIt Where to starting looking in a String.
					 * Must be a NIL (0) terminated string.
					 *
					 * @param LookFor Look for this string.
					 * Must be a NIL (0) terminated string.
					 *
					 * @return A pointer to the start of LookFor in ToSearchString,
					 * or nullptr when not found.
					 */
					static const_iterator	strstr(const_iterator & StartIt,
					                               const_iterator & LookFor);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const char * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const char16_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const char32_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const wchar_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const std::string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const std::u16string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const std::u32string & NewStr,
					                    size_t HowMany = 0);


					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const std::wstring & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const String & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char * const OldStr,
					                    const ROString & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const char * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const char16_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const char32_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const wchar_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const std::string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const std::u16string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const std::u32string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const std::wstring & NewStr,
					                    size_t HowMany = 0);
					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const String & NewStr,
					                    size_t HowMany = 0);
					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char16_t * const OldStr,
					                    const ROString & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const char * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const char16_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const char32_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const wchar_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const std::string & NewStr,
					                    size_t HowMany = 0);


					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const std::u16string & NewStr,
					                    size_t HowMany = 0);


					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const std::u32string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const std::wstring & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const String & NewStr,
					                    size_t HowMany = 0);
					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const char32_t * const OldStr,
					                    const ROString & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const char * const NewStr,
					                    size_t HowMany = 0);


					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const char16_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const char32_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const wchar_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const std::string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const std::u16string & NewStr,
					                    size_t HowMany = 0);
					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const std::u32string & NewStr,
					                    size_t HowMany = 0);
					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const std::wstring & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const String & NewStr,
					                    size_t HowMany = 0);
					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::string & OldStr,
					                    const ROString & NewStr,
					                    size_t HowMany = 0);


					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const wchar_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const std::string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const std::u16string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const std::u32string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const std::wstring & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const String & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const ROString & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const char * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const char16_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u16string & OldStr,
					                    const char32_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const char * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const char16_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const char32_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const wchar_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const std::string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const std::u16string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const std::u32string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const std::wstring & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const String & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const std::u32string & OldStr,
					                    const ROString & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const String & OldStr,
					                    const char * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const char * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const String & OldStr,
					                    const char16_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const char16_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const String & OldStr,
					                    const char32_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const char32_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const String & OldStr,
					                    const wchar_t * const NewStr,
					                    size_t HowMany = 0);


					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const wchar_t * const NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const String & OldStr,
					                    const std::string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const std::string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const String & OldStr,
					                    const std::u16string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const std::u16string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const String & OldStr,
					                    const std::u32string & NewStr,
					                    size_t HowMany = 0);
					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const std::u32string & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const String & OldStr,
					                    const std::wstring & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const std::wstring & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const String & OldStr,
					                    const String & NewStr,
					                    size_t HowMany = 0);


					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const String & NewStr,
					                    size_t HowMany = 0);


					/**
					 * Multibyte method.
					 *
					 * Replace OldStr with NewStr in this String.
					 *
					 * @param OldStr The string to look for, to be replaced.
					 *
					 * @param NewStr When OldStr is found, replace it with
					 * NewStr.
					 *
					 * @param HowMany How many OldStr to replace. When zero (0),
					 * then replace them all.
					 *
					 * @return A new String. When OldStr is not found,
					 * returns strdup(*this), when OldStr is found,
					 * returns a new string with OldStr replaced with NewStr.
					 */
					String	*	Replace(const ROString & OldStr,
					                    const ROString & NewStr,
					                    size_t HowMany = 0);

					/**
					 * Returns an iterator to the first character.
					 *
					 * @return An iterator the the start of the string.
					 */
					iterator		&	begin();

					/**
					 * Returns an iterator to the last character.
					 *
					 * @return An iterator the the end of the string.
					 */
					iterator		&	rbegin();

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @return An iterator the the end of the string.
					 */
					iterator		&	end();

					/**
					 * Returns an iterator to the first of the characters.
					 *
					 * @return An iterator the the start of the string.
					 */
					iterator		&	rend();

					/**
					 * Returns a const_iterator to the first character.
					 *
					 * @return A const_iterator the the start of the string.
					 */
					const_iterator		&	cbegin() const;

					/**
					 * Returns a reverse const iterator to the last character.
					 *
					 * @return An iterator the the end of the string.
					 */
					const_iterator		&	crbegin() const;

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @return An iterator the the end of the string.
					 */
					const_iterator		&	cend() const;

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @return An iterator the the end of the string.
					 */
					const_iterator		&	crend() const;

					/**
					 * Returns an iterator to the first character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static iterator		&	begin(const char * Str);

					/**
					 * Returns an iterator to the last character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static iterator		&	rbegin(const char * Str);

					/**
					 * Returns an iterator to the first character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static iterator		&	begin(const char16_t * Str);

					/**
					 * Returns an iterator to the last character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static iterator		&	rbegin(const char16_t * Str);

					/**
					 * Returns an iterator to the first character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static iterator		&	begin(const char32_t * Str);

					/**
					 * Returns an iterator to the last character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static iterator		&	rbegin(const char32_t * Str);

					/**
					 * Returns an iterator to the first character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static iterator		&	begin(const wchar_t * Str);

					/**
					 * Returns an iterator to the last character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static iterator		&	rbegin(const wchar_t * Str);

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static iterator		&	end(const char * Str);

					/**
					 * Returns an iterator to the start of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static iterator		&	rend(const char * Str);

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static iterator		&	end(const char16_t * Str);

					/**
					 * Returns an iterator to the start of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static iterator		&	rend(const char16_t * Str);

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static iterator		&	end(const char32_t * Str);

					/**
					 * Returns an iterator to the start of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static iterator		&	rend(const char32_t * Str);

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static iterator		&	end(const wchar_t * Str);

					/**
					 * Returns an iterator to the start of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static iterator		&	rend(const wchar_t * Str);

					/**
					 * Returns an iterator to the first character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static const_iterator		&	cbegin(const char * Str);

					/**
					 * Returns an iterator to the last character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static const_iterator		&	crbegin(const char * Str);

					/**
					 * Returns an iterator to the first character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static const_iterator		&	cbegin(const char16_t * Str);

					/**
					 * Returns an iterator to the last character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static const_iterator		&	crbegin(const char16_t * Str);

					/**
					 * Returns an iterator to the first character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static const_iterator		&	cbegin(const char32_t * Str);

					/**
					 * Returns an iterator to the last character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static const_iterator		&	crbegin(const char32_t * Str);

					/**
					 * Returns an iterator to the first character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static const_iterator		&	cbegin(const wchar_t * Str);

					/**
					 * Returns an iterator to the last character.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static const_iterator		&	crbegin(const wchar_t * Str);

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static const_iterator		&	cend(const char * Str);

					/**
					 * Returns an iterator to the start of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static const_iterator		&	crend(const char * Str);

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static const_iterator		&	cend(const char16_t * Str);

					/**
					 * Returns an iterator to the start of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static const_iterator		&	crend(const char16_t * Str);

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static const_iterator		&	cend(const char32_t * Str);

					/**
					 * Returns an iterator to the start of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static const_iterator		&	crend(const char32_t * Str);

					/**
					 * Returns an iterator to the end of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the end of the string.
					 */
					static const_iterator		&	cend(const wchar_t * Str);

					/**
					 * Returns an iterator to the start of the characters.
					 *
					 * @param Str The string to iterate.
					 *
					 * @return An iterator the the start of the string.
					 */
					static const_iterator		&	crend(const wchar_t * Str);

				protected:

					/**
					 * Does no charset work, just does strtok().
					 * Only works when InStr and Delim are in the same charset.
					 *
					 * @param InStr The input string, or nullptr.
					 *
					 * @param InStrLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Delim The delimiter string
					 *
					 * @param DelimLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return A new ROString, or nullptr.
					 */
					static ROString		*  _strtok(const char * const InStr,
					                               size_t InStrLen,
					                               const char * const Delim,
					                               size_t DelimLen,
					                               TokSave & Save);

					/**
					 * Does no charset work, just does strtok().
					 * Only works when InStr and Delim are in the same charset.
					 *
					 * @param InStr The input string, or nullptr.
					 *
					 * @param InStrLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Delim The delimiter string
					 *
					 * @param DelimLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return A new ROString, or nullptr.
					 */
					static ROString		*  _strtok(const char16_t * const InStr,
					                               size_t InStrLen,
					                               const char16_t * const Delim,
					                               size_t DelimLen,
					                               TokSave & Save);

					/**
					 * Does no charset work, just does strtok().
					 * Only works when InStr and Delim are in the same charset.
					 *
					 * @param InStr The input string, or nullptr.
					 *
					 * @param InStrLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Delim The delimiter string
					 *
					 * @param DelimLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return A new ROString, or nullptr.
					 */
					static ROString		*  _strtok(const char32_t * const InStr,
					                               size_t InStrLen,
					                               const char32_t * const Delim,
					                               size_t DelimLen,
					                               TokSave & Save);

					/**
					 * Does no charset work, just does strtok().
					 * Only works when InStr and Delim are in the same charset.
					 *
					 * @param InStr The input string, or nullptr.
					 *
					 * @param InStrLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Delim The delimiter string
					 *
					 * @param DelimLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return A new ROString, or nullptr.
					 */
					static ROString		*  _strtok(const wchar_t * const InStr,
					                               size_t InStrLen,
					                               const wchar_t * const Delim,
					                               size_t DelimLen,
					                               TokSave & Save);

					/**
					 * Does no charset work, just does strtok().
					 * Only works when InStr and Delim are in the same charset.
					 *
					 * @param InStr The input string, or nullptr.
					 *
					 * @param InStrLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Delim The delimiter string
					 *
					 * @param DelimLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return A new ROString, or nullptr.
					 */
					static ROString		*  _strtok(const ROString * InStr,
					                               size_t InStrLen,
					                               const char * const Delim,
					                               size_t DelimLen,
					                               TokSave & Save);

					/**
					 * Does no charset work, just does strtok().
					 * Only works when InStr and Delim are in the same charset.
					 *
					 * @param InStr The input string, or nullptr.
					 *
					 * @param InStrLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Delim The delimiter string
					 *
					 * @param DelimLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return A new ROString, or nullptr.
					 */
					static ROString		*  _strtok(const ROString * InStr,
					                               size_t InStrLen,
					                               const char16_t * const Delim,
					                               size_t DelimLen,
					                               TokSave & Save);

					/**
					 * Does no charset work, just does strtok().
					 * Only works when InStr and Delim are in the same charset.
					 *
					 * @param InStr The input string, or nullptr.
					 *
					 * @param InStrLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Delim The delimiter string
					 *
					 * @param DelimLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return A new ROString, or nullptr.
					 */
					static ROString		*  _strtok(const ROString * InStr,
					                               size_t InStrLen,
					                               const char32_t * const Delim,
					                               size_t DelimLen,
					                               TokSave & Save);

					/**
					 * Does no charset work, just does strtok().
					 * Only works when InStr and Delim are in the same charset.
					 *
					 * @param InStr The input string, or nullptr.
					 *
					 * @param InStrLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Delim The delimiter string
					 *
					 * @param DelimLen Because it might not be terminated with
					 * a NIL.
					 *
					 * @param Save An opaque object used to remember where
					 * strtok() left off for subsequent calls.
					 *
					 * @return A new ROString, or nullptr.
					 */
					static ROString		*  _strtok(const ROString * InStr,
					                               size_t InStrLen,
					                               const wchar_t * const Delim,
					                               size_t DelimLen,
					                               TokSave & Save);

					/**
					 * The default input charset for this object.
					 * A StringCache pointer.
					 */
					const char	*	_InputCharset;

					/**
					 * The default input charset unit width for this object.
					 */
					CharacterUnitWidth_e	_InputWidth;

					/**
					 * The default output charset for this object.
					 * A StringCache pointer.
					 */
					const char	*	_OutputCharset;

					/**
					 * The default output charset unit width for this object.
					 */
					CharacterUnitWidth_e	_OutputWidth;

					/**
					 * During append, a StringSeg (String Segment) is added,
					 * the new value is not instantly appended to the string.
					 * They are merged during the Get() methods.
					 *
					 * Supports multiple locale.
					 *
					 * @note
					 * To create a StringSeq of a difference locale that the String:
					 * Create a StringSeg with the default constructor,
					 * set the local with SetLocale(), then Set()
					 * the new string value providing the locale_t with the call
					 * to Set().
					 */
					struct StringSeg {

						/**
						 * StringSeg - Default Constructor.
						 */
						StringSeg();

						/**
						 * StringSeg - Copy constructor
						 *
						 * @param CopyFrom Copy from the named StringSeg.
						 *
						 * @param Len The number of characters to copy over.
						 * When zero (the default), all are copied.
						 */
						StringSeg(const StringSeg & CopyFrom, size_t Len = 0);

						/**
						 * StringSeg - Constructor.
						 *
						 * @param In The originating zero terminated string.
						 *
						 * @param Len The number of characters to copy over.
						 * When zero (the default), all are copied.
						 */
						StringSeg(const char * const In, size_t Len = 0);

						/**
						 * StringSeg - Constructor.
						 *
						 * @param In The originating zero terminated string.
						 *
						 * @param Len The number of characters to copy over.
						 * When zero (the default), all are copied.
						 */
						StringSeg(const char16_t * const In, size_t Len = 0);

						/**
						 * StringSeg - Constructor.
						 *
						 * @param In The originating zero terminated string.
						 *
						 * @param Len The number of characters to copy over.
						 * When zero (the default), all are copied.
						 */
						StringSeg(const char32_t * const In, size_t Len = 0);

						/**
						 * StringSeg - Constructor.
						 *
						 * @param In The originating zero terminated string.
						 *
						 * @param Len The number of characters to copy over.
						 * When zero (the default), all are copied.
						 */
						StringSeg(const wchar_t * const In, size_t Len = 0);

						/**
						 * StringSeg - Constructor.
						 *
						 * @param In The originating zero terminated string.
						 *
						 * @param Len The number of characters to copy over.
						 * When zero (the default), all are copied.
						 */
						StringSeg(const std::string & In, size_t Len = 0);

						/**
						 * StringSeg - Constructor.
						 *
						 * @param In The originating zero terminated string.
						 *
						 * @param Len The number of characters to copy over.
						 * When zero (the default), all are copied.
						 */
						StringSeg(const std::u16string & In, size_t Len = 0);

						/**
						 * StringSeg - Constructor.
						 *
						 * @param In The originating zero terminated string.
						 *
						 * @param Len The number of characters to copy over.
						 * When zero (the default), all are copied.
						 */
						StringSeg(const std::u32string & In, size_t Len = 0);

						/**
						 * StringSeg - Constructor.
						 *
						 * @param In The originating zero terminated string.
						 *
						 * @param Len The number of characters to copy over.
						 * When zero (the default), all are copied.
						 */
						StringSeg(const std::wstring & In, size_t Len = 0);

						/**
						 * StringSeq - Destructor.
						 */
						~StringSeg();

						/**
						 * Get the number of Octets in this segment.
						 *
						 * @return The number of Octets in this segment.
						 */
						size_t	Length() const;

						/**
						 * Set the locale of the StringSeg.
						 *
						 * @param TheLocale The locale to set for this string
						 * segment.
						 */
						void	SetLocale(locale_t TheLocale);

						/**
						 * Set the string value for this segment.
						 *
						 * @param TheString The string value to use.
						 *
						 * @param Len The number of characters to copy into
						 * this segment. Set to zero to copy all.
						 *
						 * @param TheLocale Optional. The locale_t to use for this
						 * string. When zero, ues the default locale.
						 */
						void	Set(const StringSeg & CopyFrom,
						            size_t Len = 0,
						            locale_t TheLocale = 0);

						/**
						 * Set the string value for this segment.
						 *
						 * @param TheString The string value to use.
						 *
						 * @param Len The number of characters to copy into
						 * this segment. Set to zero to copy all.
						 *
						 * @param TheLocale Optional. The locale_t to use for this
						 * string. When zero, ues the default locale.
						 */
						void	Set(const char * const In,
						            size_t Len = 0,
						            locale_t TheLocale = 0);

						/**
						 * Set the string value for this segment.
						 *
						 * @param TheString The string value to use.
						 *
						 * @param Len The number of characters to copy into
						 * this segment. Set to zero to copy all.
						 *
						 * @param TheLocale Optional. The locale_t to use for this
						 * string. When zero, ues the default locale.
						 */
						void	Set(const char16_t * const In,
						            size_t Len = 0,
						            locale_t TheLocale = 0);

						/**
						 * Set the string value for this segment.
						 *
						 * @param TheString The string value to use.
						 *
						 * @param Len The number of characters to copy into
						 * this segment. Set to zero to copy all.
						 *
						 * @param TheLocale Optional. The locale_t to use for this
						 * string. When zero, ues the default locale.
						 */
						void	Set(const char32_t * const In,
						            size_t Len = 0,
						            locale_t TheLocale = 0);

						/**
						 * Set the string value for this segment.
						 *
						 * @param TheString The string value to use.
						 *
						 * @param Len The number of characters to copy into
						 * this segment. Set to zero to copy all.
						 *
						 * @param TheLocale Optional. The locale_t to use for this
						 * string. When zero, ues the default locale.
						 */
						void	Set(const wchar_t * const In,
						            size_t Len = 0,
						            locale_t TheLocale = 0);

						/**
						 * Set the string value for this segment.
						 *
						 * @param TheString The string value to use.
						 *
						 * @param Len The number of characters to copy into
						 * this segment. Set to zero to copy all.
						 *
						 * @param TheLocale Optional. The locale_t to use for this
						 * string. When zero, ues the default locale.
						 */
						void	Set(const std::string & In,
						            size_t Len = 0,
						            locale_t TheLocale = 0);

						/**
						 * Set the string value for this segment.
						 *
						 * @param TheString The string value to use.
						 *
						 * @param Len The number of characters to copy into
						 * this segment. Set to zero to copy all.
						 *
						 * @param TheLocale Optional. The locale_t to use for this
						 * string. When zero, ues the default locale.
						 */
						void	Set(const std::u16string & In,
						            size_t Len = 0,
						            locale_t TheLocale = 0);

						/**
						 * Set the string value for this segment.
						 *
						 * @param TheString The string value to use.
						 *
						 * @param Len The number of characters to copy into
						 * this segment. Set to zero to copy all.
						 *
						 * @param TheLocale Optional. The locale_t to use for this
						 * string. When zero, ues the default locale.
						 */
						void		Set(const std::u32string & In,
						                size_t Len = 0,
						                locale_t TheLocale = 0);

						/**
						 * Set the string value for this segment.
						 *
						 * @param TheString The string value to use.
						 *
						 * @param Len The number of characters to copy into
						 * this segment. Set to zero to copy all.
						 *
						 * @param TheLocale Optional. The locale_t to use for this
						 * string. When zero, ues the default locale.
						 */
						void		Set(const std::wstring & In,
						                size_t Len = 0,
						                locale_t TheLocale = 0);

						/**
						 * Copy over Len characters from one StringSeg to another.
						 *
						 * @param CopyFrom Copy from this StringSeq
						 *
						 * @param Len Copy this many characters.
						 * When zero (0), copy them all.
						 */
						void		Copy(const StringSeg & CopyFrom,
						                 size_t Len);

						/**
						 * Empty out the contents.
						 */
						void		Clear();

						/**
						 * The character width of string data in this segment.
						 */
						CharacterUnitWidth_e		Width;

						/**
						 * This segments charset.
						 * When nullptr, it is the same as the systems.
						 * A StringCache pointer.
						 */
						const char	*	Charset;

						/**
						 * Locale.
						 */
						locale_t		Locale;

						/**
						 * When true, this is from Read Only (ROString) data.
						 */
						bool			IsReadOnly;

						/**
						 * The string data in Charset and Language (locale_t)
						 */
						union {
							std::string		*	Utf8;	// Non-ROString
							std::u16string	*	Utf16;	// Non-ROString
							std::u32string	*	Utf32;	// Non-ROString
							std::wstring	*	W;	// Non-ROString
							const char		*	RO8;	// ROString
							const char16_t	 *	RO16;	// ROString
							const char32_t	 *	RO32;	// ROString
							const wchar_t	 *	ROW;	// ROString
						} Str;

						/**
						 * The length of the string in character units - cached.
						 *
						 * -For Is8Bit_t: Number of 8-bit characters in _RO8.
						 * -For Is16Bit_t: Number of 16-bit characters in _RO16.
						 * -For Is32Bit_t: Number of 32-bit characters in _RO32.
						 * -For IsWBit_t: Number of wchar_t characters in _RO32.
						 */
						mutable size_t	StrUnits;
					};


					/**
					 * When true, this is a memory mapped ReadOnly string.
					 */
					bool			_ROString;

					/**
					 * When _ROString is true, this better be non-nullptr.
					 */
					StringSeg	*	_RO;

					/**
					 * All of the pieces of the Sting.
					 * For an ROString, this will be empty and the
					 * Str.{RO8,RO16,or RO32} values will be used.
					 */
					mutable std::vector<StringSeg *>	_Segments;

					bool			_InitLocale();

					/**
					 * The data in multibyte format. Cached.
					 * A StringCache pointer.
					 */
					mutable const char		*	_Str8;

					/**
					 * The data in 16-bit format. Cached.
					 * A StringCache pointer.
					 */
					mutable const char16_t	*	_Str16;

					/**
					 * The data in 32-bit format. Cached.
					 * A StringCache pointer.
					 */
					mutable const char32_t	*	_Str32;

					/**
					 * The data in wchar_t format. Cached.
					 * A StringCache pointer.
					 */
					mutable const wchar_t		*	_StrW;

					/**
					 * Mark that the input has changed and delete any
					 * mutable cached values.
					 */
					void			_SetInputChanged();

					/**
					 * set to true whenever the string is changed.
					 * set to false by get() and wget() to know if they
					 * have to translate, or if the output is still valid.
					 * (no change).
					 */
					mutable bool		_InputHasChanged;

					/**
					 * A MUTEX lock to this object.
					 */
					mutable pthread_mutex_t	_Lock;

					friend class ROString;
					friend class iterator;
					friend class iteratorType<char>;
					friend class iteratorType<char16_t>;
					friend class iteratorType<char32_t>;
					friend class iteratorType<wchar_t>;
			};
		}
	}
}

extern "C" {
	using namespace SoftwareAndServices::Library::Common;

	/**
	 * Read/Write the String in XDR format.
	 *
	 * @param xdrs An initialized XDR object.
	 *
	 * @param Pointer to the String object to be written.
	 */
	bool_t		xdr_String(XDR * xdrs,
	                       String * Pointer);

	/**
	 * Convert a (char*) to upper case - in place.
	 *
	 * @param ToConvert The string to convert to UPPER CASE.
	 */
	void			ToUpper(char * ToConvert);

	/**
	 * Convert a (char16_t*) to upper case - in place.
	 *
	 * @param ToConvert The string to convert to UPPER CASE.
	 */
	void			ToUpper16(char16_t * ToConvert);

	/**
	 * Convert a (char32_t*) to upper case - in place.
	 *
	 * @param ToConvert The string to convert to UPPER CASE.
	 */
	void			ToUpper32(char32_t * ToConvert);

	/**
	 * Convert a (char*) to lower case - in place.
	 *
	 * @param ToConvert The string to convert to upper case.
	 */
	void			ToLower(char * ToConvert);

	/**
	 * Convert a (char16_t*) to lower case - in place.
	 *
	 * @param ToConvert The string to convert to upper case.
	 */
	void			ToLower16(char16_t * ToConvert);

	/**
	 * Convert a (char32_t*) to lower case - in place.
	 *
	 * @param ToConvert The string to convert to upper case.
	 */
	void			ToLower32(char32_t * ToConvert);
}
//#include <SaS/String/StringLocale.hpp>
#include <SaS/String/StringCache.hpp>

#endif // SOFTWARE_AND_SERVICES_LIBRARY_STRING_STRING_HPP_
